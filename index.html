<!DOCTYPE html>
<html>

<head>
    <title>PixelPlot V2.1 - Elite Pixel Real Estate</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&family=Fira+Code:wght@400;500&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-dark: #020617;
            --card-bg: #0f172a;
            --accent: #38bdf8;
            --accent-glow: rgba(56, 189, 248, 0.3);
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --text-main: #f8fafc;
            --text-dim: #94a3b8;
            --pixel-size: 5px;
            --border-color: #1e293b;
            --grid-size: 280;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-dark);
            color: var(--text-main);
            margin: 0;
            padding: 0;
            overflow: hidden;
            /* Prevent body scroll */
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            padding: 20px 40px;
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: -0.5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo span {
            color: var(--accent);
        }

        .wallet-status {
            display: flex;
            align-items: center;
            gap: 20px;
            background: rgba(2, 6, 23, 0.6);
            padding: 8px 16px;
            border-radius: 99px;
            border: 1px solid var(--border-color);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
            box-shadow: 0 0 10px var(--success);
        }

        .main-layout {
            flex: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
            overflow: hidden;
            position: relative;
        }

        /* --- LEFT COLUMN: GRID --- */
        .viewport {
            flex: 1;
            background: radial-gradient(circle at center, #0f172a 0%, #020617 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
            /* CRITICAL: contain the zoomed grid */
        }

        #grid-container {
            position: relative;
            padding: 2px;
            background: #1e293b;
            border-radius: 4px;
            box-shadow: 0 0 60px rgba(0, 0, 0, 0.6);
            cursor: grab;
            transform-origin: 0 0;
            display: inline-block;
            transition: transform 0.05s ease-out;
            /* Smooth small adjustments */
        }

        #grid-container:active {
            cursor: grabbing;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(var(--grid-size), var(--pixel-size));
            background: #334155;
            user-select: none;
            cursor: crosshair;
            border: 1px solid #475569;
            position: relative;
        }

        .pixel {
            width: var(--pixel-size);
            height: var(--pixel-size);
            border: 0.1px solid rgba(255, 255, 255, 0.03);
            transition: background 0.1s;
            position: relative;
        }

        /* Small dot inside each pixel */
        .pixel::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 2px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .pixel.is-filled::after {
            opacity: 0;
        }

        .pixel:hover {
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.5);
            z-index: 10;
        }

        .pixel.modified {
            box-shadow: inset 0 0 0 2px var(--accent);
            z-index: 5;
        }

        /* Rent mode styles */
        body.rent-mode #grid {
            filter: brightness(0.5);
        }

        /* Show grid lines in appropriate modes */
        body.history-mode .quadrant-grid-line {
            display: none !important;
        }

        /* Grid lines are now visible in rent mode by default unless we specifically hide them */

        .pixel.rent-selected {
            filter: brightness(1.8) !important;
            box-shadow: inset 0 0 0 1px rgba(139, 92, 246, 0.8) !important;
            z-index: 15;
        }

        .pixel.rented-by-other {
            opacity: 0.6;
        }

        .pixel.rented-by-other::before {
            content: '';
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(45deg,
                    transparent,
                    transparent 2px,
                    rgba(245, 158, 11, 0.3) 2px,
                    rgba(245, 158, 11, 0.3) 4px);
            pointer-events: none;
        }

        .rented-rect {
            position: absolute;
            border: 1px solid rgba(139, 92, 246, 0.6);
            background: rgba(139, 92, 246, 0.1);
            pointer-events: none;
            box-shadow: inset 0 0 8px rgba(139, 92, 246, 0.2);
            z-index: 25;
            transition: all 0.2s;
        }

        .rented-rect:hover {
            background: rgba(139, 92, 246, 0.25);
            border-color: rgba(139, 92, 246, 1);
        }

        /* Quadrant Overlays */
        .quadrant-lines {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 20;
        }

        .quadrant-lines::before,
        .quadrant-lines::after {
            display: none !important;
        }

        .quadrant-label {
            position: absolute;
            font-size: 10px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: none;
        }

        /* --- RIGHT COLUMN: TOOLS --- */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            border: 1px solid var(--border-color);
            padding: 20px;
        }

        .card h3 {
            margin: 0 0 10px 0;
            font-size: 0.75rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .palette {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 4px;
        }

        .swatch {
            aspect-ratio: 1;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
            position: relative;
        }

        .swatch:hover {
            transform: scale(1.1);
        }

        .swatch.selected {
            border-color: white;
            box-shadow: 0 0 12px var(--accent-glow);
            z-index: 2;
        }

        .quad-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .quad-btn {
            background: #1e293b;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 12px;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quad-btn:hover {
            border-color: var(--accent);
            background: #262f3f;
        }

        .quad-btn.rented {
            border-color: var(--warning);
        }

        .quad-btn .title {
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 4px;
            display: block;
        }

        .quad-btn .meta {
            font-size: 0.75rem;
            color: var(--text-dim);
            display: block;
        }

        .quad-btn .time {
            color: var(--warning);
            font-family: 'Fira Code', monospace;
            font-size: 11px;
        }

        /* --- BOTTOM SHELF: LOGS --- */
        .bottom-shelf {
            position: relative;
            background: rgba(15, 23, 42, 0.98);
            backdrop-filter: blur(20px);
            border-top: 1px solid var(--accent);
            height: 280px;
            z-index: 1000;
            display: grid;
            grid-template-columns: 300px minmax(300px, 1fr) minmax(300px, 1fr) 350px;
            box-shadow: 0 -20px 50px rgba(0, 0, 0, 0.8);
        }

        .bottom-shelf.visible {
            transform: translateY(0);
        }

        .queue-summary {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .queue-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .queue-item .label {
            font-size: 0.75rem;
            color: var(--text-dim);
            text-transform: uppercase;
        }

        .queue-item .val {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent);
        }

        .queue-actions {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .btn {
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-success {
            background: var(--success);
            color: white;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }

        .btn-ghost {
            background: transparent;
            color: var(--text-dim);
            border: 1px solid var(--border-color);
        }

        .btn-ghost:hover {
            border-color: var(--danger);
            color: var(--danger);
        }

        .tx-list {
            margin-top: 10px;
            max-height: 80px;
            overflow-y: auto;
            font-family: 'Fira Code', monospace;
            font-size: 10px;
            color: var(--text-dim);
        }

        /* Animations */
        @keyframes pulse {
            0% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.6;
            }
        }

        .loading-text {
            animation: pulse 1.5s infinite;
        }

        #rent-queue-info {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.3);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            display: none;
            font-size: 0.85rem;
            color: #c4b5fd;
        }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        .modal {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            padding: 30px;
            border-radius: 20px;
            width: 400px;
            box-shadow: 0 40px 100px rgba(0, 0, 0, 1);
        }

        .log-container {
            padding: 8px;
            overflow-y: auto;
            border-right: 1px solid var(--border-color);
            font-family: 'Fira Code', monospace;
            background: #020617;
            max-height: 260px;
        }

        .log-container h4 {
            margin: 0 0 8px 0;
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
        }

        .log-msg {
            padding: 3px 6px;
            border-left: 2px solid var(--accent);
            margin-bottom: 3px;
            font-size: 10px;
            animation: slideIn 0.2s ease-out;
            color: var(--text-dim);
            word-break: break-word;
        }

        .log-msg.error {
            border-left-color: var(--danger);
            color: #fca5a5;
        }

        .log-msg.success {
            border-left-color: var(--success);
            color: #6ee7b7;
        }

        .log-msg a {
            color: var(--accent);
            text-decoration: none;
            font-weight: 500;
        }

        .log-msg a:hover {
            text-decoration: underline;
        }

        .queue-panel {
            padding: 15px;
            overflow-y: auto;
        }

        .plot-group {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #334155;
        }

        .plot-group h4 {
            margin: 0 0 5px 0;
            font-size: 11px;
            color: var(--accent);
            display: flex;
            justify-content: space-between;
        }

        /* Compact queue cubes */
        .queue-cubes {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 5px;
        }

        .queue-cube {
            width: 50px;
            height: 50px;
            background: rgba(56, 189, 248, 0.15);
            border: 1px solid var(--accent);
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .queue-cube:hover {
            background: rgba(56, 189, 248, 0.3);
            transform: scale(1.05);
        }

        .queue-cube.rent-cube {
            background: rgba(139, 92, 246, 0.1);
            border-color: #8b5cf6;
            padding: 4px;
        }

        .queue-cube.rent-cube:hover {
            background: rgba(139, 92, 246, 0.2);
        }

        .queue-cube.processing {
            animation: cubeProcess 0.5s infinite;
            border-color: var(--success);
        }

        .queue-cube.error {
            border-color: var(--danger);
            background: rgba(239, 68, 68, 0.15);
        }

        .queue-cube .plot-num {
            font-size: 16px;
            font-weight: bold;
            color: var(--text-main);
        }

        .queue-cube .count {
            font-size: 10px;
            color: var(--accent);
        }

        .queue-cube.rent-cube .count {
            color: #a78bfa;
        }

        /* Rent cube quadrant grid */
        .rent-quad-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2px;
            width: 24px;
            height: 24px;
            margin-bottom: 2px;
        }

        .rent-quad-cell {
            background: rgba(139, 92, 246, 0.2);
            border-radius: 2px;
        }

        .rent-quad-cell.filled {
            background: rgba(139, 92, 246, 0.8);
        }

        @keyframes cubeProcess {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Rent info tooltip */
        .rent-info-popup {
            position: fixed;
            background: var(--card-bg);
            border: 1px solid #8b5cf6;
            border-radius: 8px;
            padding: 12px;
            z-index: 2000;
            min-width: 180px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            font-size: 11px;
        }

        .rent-info-popup h4 {
            margin: 0 0 8px 0;
            color: #a78bfa;
            font-size: 12px;
        }

        .rent-info-popup .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            color: var(--text-dim);
        }

        .rent-info-popup .info-row .val {
            color: var(--text-main);
            font-family: 'Fira Code', monospace;
        }

        .rent-info-popup .quad-status {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            margin-top: 8px;
        }

        .rent-info-popup .quad-box {
            padding: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            text-align: center;
            font-size: 10px;
        }

        .rent-info-popup .quad-box.available {
            border: 1px solid var(--success);
            color: var(--success);
        }

        .rent-info-popup .quad-box.rented {
            border: 1px solid var(--warning);
            color: var(--warning);
        }

        /* Rent period selector */
        .rent-period-selector {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .rent-period-btn {
            flex: 1;
            padding: 6px 8px;
            background: #1e293b;
            border: 1px solid var(--border-color);
            color: var(--text-dim);
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            text-align: center;
        }

        .rent-period-btn.active {
            background: rgba(139, 92, 246, 0.3);
            border-color: #8b5cf6;
            color: #a78bfa;
        }

        /* History mode styles */
        body.history-mode #grid {
            filter: saturate(0.7);
        }

        .btn-small {
            padding: 4px 8px;
            background: #1e293b;
            border: 1px solid var(--border-color);
            color: var(--text-main);
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
        }

        .btn-small:hover {
            background: #334155;
        }

        .btn-small.playing {
            background: var(--success);
            border-color: var(--success);
        }

        .pixel.history-updated {
            animation: historyPulse 0.5s ease-out;
        }

        @keyframes historyPulse {
            0% {
                box-shadow: inset 0 0 0 3px var(--success);
            }

            100% {
                box-shadow: none;
            }
        }

        /* Rented quadrant indicator */
        .pixel.rented-q {
            position: relative;
        }

        .pixel.rented-q::before {
            content: '';
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(45deg,
                    transparent,
                    transparent 1px,
                    rgba(245, 158, 11, 0.4) 1px,
                    rgba(245, 158, 11, 0.4) 2px);
            pointer-events: none;
        }

        .rent-badge {
            position: absolute;
            font-size: 6px;
            color: #fff;
            background: rgba(139, 92, 246, 0.9);
            padding: 2px 4px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 50;
            display: flex;
            flex-direction: column;
            gap: 2px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            min-width: 30px;
            max-width: 60px;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .time-left {
            font-weight: 800;
            color: #ffd700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .rent-comment {
            font-size: 5px;
            font-style: italic;
            opacity: 0.9;
            line-height: 1;
        }

        .pixel.rented-q {
            position: relative;
            filter: brightness(1.3) saturate(1.4);
            z-index: 1;
            /* Bring slightly above normal pixels */
        }

        .pixel.rented-q::before {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(139, 92, 246, 0.3);
            border: 0.5px solid rgba(139, 92, 246, 0.6);
            pointer-events: none;
            box-shadow: inset 0 0 4px rgba(139, 92, 246, 0.4);
        }

        .controls-panel {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border-left: 1px solid var(--border-color);
        }

        .mode-switch {
            display: flex;
            background: #1e293b;
            padding: 4px;
            border-radius: 8px;
            gap: 4px;
        }

        .mode-btn {
            flex: 1;
            padding: 8px;
            border: none;
            background: transparent;
            color: var(--text-dim);
            cursor: pointer;
            border-radius: 6px;
            font-weight: 600;
            font-size: 13px;
        }

        .mode-btn.active {
            background: var(--accent);
            color: white;
        }

        .fee-slider-container {
            margin-top: 10px;
        }

        .slider-val {
            float: right;
            color: var(--warning);
            font-family: 'Fira Code', monospace;
        }

        @keyframes slideIn {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* --- MOBILE ADAPTATION --- */
        @media (max-width: 768px) {
            header {
                padding: 10px 15px;
                flex-direction: column;
                gap: 10px;
                height: auto;
            }

            .logo {
                font-size: 1.2rem;
            }

            .wallet-status {
                padding: 4px 10px;
            }

            #contract-badge {
                display: none;
            }

            .bottom-shelf {
                flex-direction: column;
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                height: auto;
                max-height: 50vh;
                overflow-y: auto;
                background: rgba(15, 23, 42, 0.95);
                backdrop-filter: blur(20px);
                z-index: 1000;
                border-top: 1px solid var(--accent);
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }

            .bottom-shelf.collapsed {
                transform: translateY(calc(100% - 40px));
            }

            .log-container,
            .queue-panel,
            .controls-panel {
                border-left: none;
                border-bottom: 1px solid var(--border-color);
                width: 100% !important;
            }

            .viewport {
                height: 100vh;
                padding-bottom: 40px;
                /* Space for collapsed shelf tab */
            }

            .zoom-slider-container {
                bottom: 60px !important;
                right: 20px !important;
            }

            .interaction-guide {
                display: none !important;
            }
        }

        /* Zoom Slider Styling */
        .zoom-slider-container {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(10px);
            padding: 12px;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            border: 1px solid var(--border-color);
            z-index: 50;
        }

        .zoom-slider-container label {
            font-size: 10px;
            color: var(--accent);
            font-weight: 600;
        }

        #zoom-range {
            writing-mode: bt-lr;
            /* Vertical slider */
            appearance: slider-vertical;
            width: 8px;
            height: 150px;
            cursor: pointer;
        }

        .shelf-toggle {
            display: none;
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 5px;
            background: var(--accent);
            border-radius: 99px;
            margin: 10px 0;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .shelf-toggle {
                display: block;
            }
        }

        .locked-interaction {
            pointer-events: none !important;
        }

        .zoom-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(239, 68, 68, 0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>

<body>
    <header>
        <div class="logo">PIXEL<span>PLOT</span> V2.1</div>
        <div style="display:flex; gap:20px; align-items: center">
            <div id="contract-badge"
                style="font-size: 11px; background: #1e293b; padding: 4px 10px; border-radius: 4px; color: var(--text-dim);">
                CONTRACT: <span id="display-contract-id">...</span>
            </div>
            <div class="wallet-status">
                <div class="status-dot"></div>
                <div style="text-align:left">
                    <div style="display:flex; align-items:center; gap:5px;">
                        <span id="display-wallet-label"
                            style="font-size: 9px; background: var(--accent); color: #000; padding: 1px 4px; border-radius: 3px; font-weight: 800; display:none;">SELLER</span>
                        <div id="display-wallet-addr" style="font-size: 13px; font-weight: 600;">Connecting...</div>
                    </div>
                    <div id="display-wallet-balance" style="font-size: 11px; color: var(--success);">0 SAT</div>
                </div>
            </div>
        </div>
    </header>

    <div class="main-layout">
        <div class="viewport">
            <div id="grid-container">
                <div class="quadrant-lines" id="quadrant-overlay">
                    <!-- Dynamic Grid Overlays -->
                </div>
                <div id="grid"></div>
            </div>
            <div class="zoom-slider-container">
                <label>ZOOM</label>
                <input type="range" id="zoom-range" min="0.1" max="15" step="0.1" value="1.0"
                    oninput="handleSliderZoom(this.value)">
                <span id="zoom-value" style="font-size: 10px; font-family: 'Fira Code'">1.0x</span>
            </div>

            <div id="zoom-warning" class="zoom-warning">Zoom in more to paint!</div>

            <div class="interaction-guide"
                style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 99px; backdrop-filter: blur(10px); color: var(--text-dim); font-size: 0.75rem; display: flex; gap: 20px; pointer-events: none; border: 1px solid var(--border-color);">
                <span>L-Click: Draw</span>
                <span>R-Drag: Pan</span>
                <span>Pinch/Scroll: Zoom</span>
            </div>
        </div>
    </div>

    <div class="bottom-shelf" id="bottom-shelf">
        <div class="shelf-toggle" onclick="toggleShelf()"></div>
        <div class="log-container">
            <h4>CONSOLE</h4>
            <div id="log-stream"></div>
        </div>

        <div
            style="display: flex; flex-direction: column; padding: 15px; gap: 10px; border-right: 1px solid var(--border-color);">
            <div class="card" id="palette-card" style="padding: 0; border: none; background: transparent;">
                <h3>PALETTE <span id="selected-price" style="color: var(--accent)">1 SAT</span></h3>
                <div class="palette" id="palette"></div>
            </div>
            <div id="plot-info-card"
                style="font-size: 11px; color: var(--text-dim); background: rgba(255,255,255,0.03); padding: 10px; border-radius: 8px; border: 1px solid var(--border-color);">
                Hover over grid to see plot info
            </div>
        </div>

        <div class="queue-panel">
            <h3 id="queue-title" style="margin:0 0 10px 0; font-size:11px; color: var(--text-dim);">TRANSACTION QUEUE
            </h3>
            <div id="queue-cubes" class="queue-cubes">
                <div style="color:rgba(255,255,255,0.2); text-align:center; padding:20px; width:100%;">No pending
                    actions</div>
            </div>
            <div id="queue-errors" style="margin-top:10px; display:none;">
                <h4 style="margin:0 0 5px 0; font-size:10px; color: var(--danger);">ERRORS (will retry)</h4>
                <div id="error-cubes" class="queue-cubes"></div>
            </div>
        </div>

        <div class="controls-panel">
            <div style="display: flex; gap: 10px;">
                <div style="flex: 1;">
                    <label style="font-size:10px; color: var(--text-dim); display:block; margin-bottom:4px">WIF
                        KEY</label>
                    <input type="password" id="wif-input" class="wallet-input"
                        placeholder="Enter your private key (WIF)"
                        style="width: 100%; background: #020617; border: 1px solid var(--border-color); color: white; padding: 6px; border-radius: 4px; font-size: 11px;"
                        onchange="refreshWallet()">
                </div>
                <div style="flex: 1;">
                    <label
                        style="font-size:10px; color: var(--text-dim); display:block; margin-bottom:4px">COMMENT</label>
                    <input type="text" id="tx-comment" placeholder="Add a comment..."
                        style="width: 100%; background: #020617; border: 1px solid var(--border-color); color: white; padding: 6px; border-radius: 4px; font-size: 11px;">
                </div>
                <div>
                    <label
                        style="font-size:10px; color: var(--text-dim); display:block; margin-bottom:4px">PROVIDER</label>
                    <select id="provider-select"
                        style="background:#020617; border:1px solid var(--border-color); color:white; padding:5px; border-radius:4px; font-size:11px">
                        <option value="woc" selected>WOC</option>
                        <option value="taal">Taal</option>
                        <option value="scrypt">sCrypt</option>
                    </select>
                </div>
            </div>

            <div class="mode-switch">
                <button class="mode-btn active" id="paint-mode-btn" onclick="setMode('paint')">PAINT</button>
                <button class="mode-btn" id="rent-mode-btn" onclick="setMode('rent')">RENT</button>
                <button class="mode-btn" id="history-mode-btn" onclick="setMode('history')">HISTORY</button>
            </div>

            <div id="rent-options" style="display:none;">
                <label style="font-size:10px; color: var(--text-dim); display:block; margin-bottom:4px">TOOL</label>
                <div class="mode-switch" style="margin-bottom: 10px; padding: 2px;">
                    <button class="mode-btn" id="rent-tool-interact" style="font-size: 10px; padding: 4px;"
                        onclick="setTool('interact')">SELECT</button>
                    <button class="mode-btn active" id="rent-tool-hand" style="font-size: 10px; padding: 4px;"
                        onclick="setTool('hand')">DRAG</button>
                </div>

                <label style="font-size:10px; color: var(--text-dim); display:block; margin-bottom:4px">RENT
                    PERIOD</label>
                <div class="rent-period-selector">
                    <button class="rent-period-btn" onclick="setRentPeriod(6)">6 blk</button>
                    <button class="rent-period-btn" onclick="setRentPeriod(36)">36 blk</button>
                    <button class="rent-period-btn active" onclick="setRentPeriod(144)">1 day</button>
                    <button class="rent-period-btn" onclick="setRentPeriod(1008)">1 week</button>
                </div>
            </div>

            <div id="history-options" style="display:none;">
                <label style="font-size:10px; color: var(--text-dim); display:block; margin-bottom:4px">TOOL</label>
                <div class="mode-switch" style="margin-bottom: 10px; padding: 2px;">
                    <button class="mode-btn" id="history-tool-interact" style="font-size: 10px; padding: 4px;"
                        onclick="setTool('interact')">INFO</button>
                    <button class="mode-btn active" id="history-tool-hand" style="font-size: 10px; padding: 4px;"
                        onclick="setTool('hand')">DRAG</button>
                </div>

                <label style="font-size:10px; color: var(--text-dim); display:block; margin-bottom:4px">RETRIEVE
                    HISTORY</label>
                <div style="display:flex; flex-direction:column; gap:5px; margin-bottom:8px;">
                    <div style="display:flex; gap:5px;">
                        <input type="number" id="history-start-block" placeholder="Start Blk"
                            style="flex:1; background:#020617; border:1px solid var(--border-color); color:white; padding:5px; border-radius:4px; font-size:11px">
                        <input type="number" id="history-end-block" placeholder="End Blk"
                            style="flex:1; background:#020617; border:1px solid var(--border-color); color:white; padding:5px; border-radius:4px; font-size:11px">
                    </div>
                    <div style="display:flex; gap:5px;">
                        <input type="number" id="history-limit" value="50" min="10" max="500"
                            style="width: 50px; background:#020617; border:1px solid var(--border-color); color:white; padding:5px; border-radius:4px; font-size:11px">
                        <button class="btn-small" style="flex:1"
                            onclick="loadHistory(document.getElementById('history-limit').value, document.getElementById('history-start-block').value, document.getElementById('history-end-block').value)">RETRIEVE</button>
                    </div>
                </div>
                <div id="history-controls"
                    style="display:none; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; border: 1px solid var(--border-color);">
                    <div style="display:flex; align-items:center; gap:8px; margin-bottom:5px;">
                        <button class="btn-small" onclick="historyStep(-1)">◀</button>
                        <input type="range" id="history-slider" min="0" max="0" value="0" style="flex:1;"
                            oninput="historySeek(this.value)">
                        <button class="btn-small" onclick="historyStep(1)">▶</button>
                        <button class="btn-small" id="history-play-btn" onclick="historyTogglePlay()">▶▶</button>
                    </div>
                    <div id="history-info" style="font-size:10px; color:var(--text-dim); text-align:center;">
                        0 / 0
                    </div>
                </div>
            </div>

            <div class="fee-slider-container">
                <label style="font-size:10px; color: var(--text-dim);">FEE RATE <span class="slider-val"
                        id="fee-val">100</span> sat/kb</label>
                <input type="range" id="fee-slider" min="50" max="1000" step="10" value="100"
                    style="width:100%; height: 4px;" oninput="updateFeeLabel(this.value)">
            </div>

            <div style="display:flex; gap:10px; margin-top:5px">
                <button class="btn btn-ghost" style="flex:1; padding: 8px; font-size: 12px;"
                    onclick="resetAll()">RESET</button>
                <button class="btn btn-success" id="process-btn" style="flex:2; padding: 8px; font-size: 12px;"
                    onclick="startExecution()">
                    EXECUTE
                </button>
            </div>
        </div>
    </div>

    <script src="./scrypt_bundle.js"></script>

    <script>
        const COLORS = [
            "#FFFFFF", "#000000", "#FF4500", "#FFA800", "#FFD635", "#00A368", "#7EED56", "#2450A4",
            "#3690EA", "#51E9F4", "#811E9F", "#B44AC0", "#FF99AA", "#9C6926", "#D4D7D9", "#898D90",
            "#FF3881", "#00756F", "#009EAA", "#493AC1", "#00CC78", "#6D482F", "#6D001A", "#FFF8D8",
            "#00CCC0", "#94B3FF", "#E4ABFF", "#DE107F", "#FFB470", "#515252", "#BE0039", "#FF96AA"
        ];

        // --- STATE ---
        let plots = []; // 9 plot objects: { index, genesisId, headId, instance, originalPixels, modifiedIndices, queuedRents }
        let currentPixels = new Uint8Array(280 * 280).fill(0);
        let selectedColor = 0;
        let isDrawing = false;
        let currentMode = 'paint'; // 'paint', 'rent', or 'history'
        let feeRate = 100;
        let scale = 1.0;
        let selectedTool = 'hand'; // 'hand' or 'color'
        const PAINT_ZOOM_THRESHOLD = -1; // Disabled
        let rentPeriod = 144; // Default 1 day (144 blocks)
        let errorQueue = []; // Plots that failed and need retry with new head
        let rentInfoPopup = null; // Current rent info popup element

        // History mode state
        let historyEvents = []; // Array of { txid, timestamp, plotIndex, type, data }
        let historyIndex = 0;
        let historyPlaying = false;
        let historyPlayInterval = null;
        let historyBasePixels = null; // Pixels before history playback
        let currentBlockHeight = 0;

        // Pan & Zoom state
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // --- INIT ---
        window.onload = () => {
            initPalette();
            initPlotsMetadata();

            // Priority 1: UI Shell & Zoom
            initPanZoom();
            refreshWallet();

            // Priority 2: Create Grid Nodes (Expensive)
            setTimeout(() => {
                initGrid();
                zoomToPlot(4); // Zoom to central plot immediately
                addLog("Grid UI initialized. Zoomed to center plot.");

                // Priority 3: Fetch Blockchain Data (Async)
                loadGrid();
            }, 100);

            // Start block height refresh timer
            setInterval(updateBlockHeight, 30000); // Every 30s

            updatePriceLabel();
            document.getElementById('bottom-shelf').classList.add('visible');
        };

        async function updateBlockHeight() {
            try {
                const url = 'https://api.whatsonchain.com/v1/bsv/main/chain/info';
                const resp = await fetch(`/api/proxy?url=${encodeURIComponent(url)}&t=${Date.now()}`);
                if (resp.ok) {
                    const data = await resp.json();
                    if (data.blocks > currentBlockHeight) {
                        currentBlockHeight = data.blocks;
                        console.log("Current Block Height:", currentBlockHeight);
                        if (currentMode === 'rent') showRentedQuadrants();
                    }
                }
            } catch (e) { console.error("Height update failed:", e); }
        }

        function initPlotsMetadata() {
            // 10x10 Grid Expansion (100 plots)
            // Pattern follows ring-expansion visual layout
            const meta = [
                { "index": 0, "owner": "1P4W5w2bL6wEmjrJfgUy37naivcXQduqNq", "txid": "8b4dc8af57b2974a413ec6fe99ff8a3e5ea34ca7045c39af5aac84e8fc340a40" },
                { "index": 1, "owner": "17FK3tdKqa5vD2VLFw9gECasDSVfPKKzgM", "txid": "a98637337a29306b9bf431586562898c6c09f5d1882615ddf45d46449f11ea5e" },
                { "index": 2, "owner": "114aQeouD8puU1m4QcTBXA7Zam8CYuGDDi", "txid": "1f868a883cfb2d5c008fa2689f442400a2898395b273250d2033604b67e267a6" },
                { "index": 9, "owner": "1HPU58vxvwr9gg2Fh6obvw7cedPVUpQacY", "txid": "3c3e5411cabc58a10ea958479318fe9e17c2fe7a372a6138b5b4214c2f5e9601" },
                { "index": 16, "owner": "1CTrUetoWrEGXLSzCcL3CXwU7gF7g2PWE4", "txid": "13eb0148af862427c9414b89897587d3b85f4ae34c422c87a6a7bb9a6fe3f45a" },
                { "index": 25, "owner": "1LR1SG389pvW2cdeyX5tZcRn6ZeQEQD7KH", "txid": "cc72867dea2918cd4ddfc2bb9904151b55e5934a76439519dea1df3599dc05e7" },
                { "index": 36, "owner": "1QAVYFVFyMrjdzinNdT5NcQBnejisiXDDV", "txid": "83676b887d9d5e9042c1e43a2fc1cf1656b34a722996300cde16a3a57b7621d1" },
                { "index": 49, "owner": "1Cc8QLojghsCB99XRjtFdTDqQVUarutZos", "txid": "d6e5c2155d5d9742a7a18d135477d04a4e26d88da259f0a3162d640d5a5ae8ed" },
                { "index": 64, "owner": "1UTNcM25jccZijzX4fXBEC38d7m8M3vbi", "txid": "35a7be457d5ba9dea36f3b6d9efa10f0e0aa1c19ebafbc504f9b6fde5f6c9167" },
                { "index": 81, "owner": "1KDxKxc8CfbC5dWpoEWaBdMoMdpXrrggbB", "txid": "50ee2a74368b7a10895c817b3b0d31cc13f283798248b87a0c0b37d56bbb8b30" },
                { "index": 3, "owner": "1PGNR2KMikwwN9m1rvNAgZBCBrZUr5eHbJ", "txid": "a93cb7d27575edde0fd5594669e23c0c526a4843e7b979fa4c7a64462e5cd2ad" },
                { "index": 4, "owner": "15pRFCaqTZZS1atfxyeJ9AAPK3fVYbuAAV", "txid": "269aabf8975efbaa7fbd5179c931b193ce147aa2a24bb6f9b95cc51a54258a23" },
                { "index": 5, "owner": "1Ab9TYd3ht1vXQMb3v64FY3iAkpowr7hJJ", "txid": "90c1f206a79cb760c35eee1478c5498c16881752e2aba6a5a73122bd54cc78a1" },
                { "index": 10, "owner": "1GfrZQHrv2o9CrPLW3t45j7ePGG1hvxB4r", "txid": "c71cde889be3c4a5a7336d1f5cfcc61bd84bf94565eb6691f9b9f7d20f025233" },
                { "index": 17, "owner": "17VYrhG27V2tMB3Jv9rmMHoDaV32BNmtre", "txid": "7794ffe1f5af636119c9cd12eb84d29561b4330d2a1ab212bb03d2a9a5965fc3" },
                { "index": 26, "owner": "173Q8MrfKG2SpSYLPSmwE8bx4zsPYaNE1z", "txid": "23b9f9050bba6cf726b4078a60e982b84279d30b7baaf574603aeda1ac2e1fd8" },
                { "index": 37, "owner": "1EDfN4gdL5Q9AgFXLCcgRBsBDf37he8Rm2", "txid": "7269446f6d7edbc9cc60e66c668e5ea3b6d34a9e9f4c6921515658a06dfa893b" },
                { "index": 50, "owner": "13Zb5Rxt7sGLiqUTM3KDs9vXMaJcy3CmC1", "txid": "799440c20f411056da45f16a4923b6febc313ab5c352b28b4c7e8d94d60f572e" },
                { "index": 65, "owner": "1DRZvHeS1y2AatqmExLc4r1m79PH2dWL1y", "txid": "65c0d5da648185cd4565c0ebe23241106473baead3e862348a84ccc017282ba3" },
                { "index": 82, "owner": "17ETMvdKRMGEVzWpEkWzRkt9DMU8nGHTBN", "txid": "e18cb6d4c45cb30958f183c641696847cc8bf2602998c07a964564003993f9eb" },
                { "index": 6, "owner": "1GQX8HfxPRREEbCjy3Vbp57CyfhHdo3Yes", "txid": "423075e2f3e3cdb2a641c15f37fe67302a647d24f51bba5c0bd4d5cbf77541bf" },
                { "index": 7, "owner": "13gqJQv6srBua5MAKwVK6jLRKqnQivQpju", "txid": "a246929ce2377e5400f4afc86e455ab2adf8b6cc3e1782395c76a4619471ed65" },
                { "index": 8, "owner": "16p13WZgWGqENoFvoaQ1kexT2ZEXBYfw3b", "txid": "2b030ed8604f99ac247983c24c3555d810126262c4a04493c03573bad84251f5" },
                { "index": 11, "owner": "13Q7EjhxxU79xwHCZSjx5BcRJPtwBHM1wi", "txid": "12a1ecc41fd973f7a62ed6646f624e8d03cfb4e29fba37a41b111ff670b1a9e9" },
                { "index": 18, "owner": "1J5m332nTUE1L1qHh6SLJyAzyRorcDAJsi", "txid": "390192516dbda540a856f4242303a8fd9131bee3a4b92088dabb2f1122f02d32" },
                { "index": 27, "owner": "1BH8cDuc6LLgkndxoTgnV1P6VHsnLMj123", "txid": "9e25e3e74428c10522c91b329c7694fe05f6478fb5735a48413172fa4442e0cb" },
                { "index": 38, "owner": "1MHnZFU1SaJ1pgHFZCQAMM3BQqZSm8EnzR", "txid": "a7cc04987982a2c11983efc41f40c5e7b626f9ba29576e41a713e03e57dd54b5" },
                { "index": 51, "owner": "1HdG4JvVjfcmEerWASgYFa3SQGnEAG7Npu", "txid": "f31bd60d41a1214e14313d9e9ee2cc5f397208c3dd39b986f35ff71bb55b23b1" },
                { "index": 66, "owner": "1MKiGCtkgW54yKo57uHReUD3eQxmnH3S9M", "txid": "c62f59e5e64f436860864c5a5af1c0cf7cd3c296b9bbabdfb7a4907895a65ab2" },
                { "index": 83, "owner": "1A3Z2w8KvDPMEvh87kVokMRSDpacus4ZmP", "txid": "d7367b902fe4133fa8e07fa3b0b371d68a07721647b7deae1dc6957e523c985d" },
                { "index": 12, "owner": "121CH8s6r7xbS6SmPfbYY1M6k6HLxTP5D3", "txid": "459cc2e203f9e5d2220f922d01f59ed74a24d773430ceeb3da1d0f71999972ff" },
                { "index": 13, "owner": "19MB7X2DdWhuf8mYvi1QXPocdkivi726qX", "txid": "37d01fbe06f4c11448c6237afafeb34cd47a014a5ba56b7ddb4261789f840fa6" },
                { "index": 14, "owner": "1GqKQvHq7Yd127ZHZoQqod2hZsF8iDFneW", "txid": "f2664c289e5683876093fca4086e613d26e08a1354e9b472f7a355d2b54b7320" },
                { "index": 15, "owner": "1C1U2X9U74CVd1WQrFQianAbFrPtcTdCyE", "txid": "53b6724398fd8eed7d8c9375b5a4b81863a815f849892a02cecee5b14cac84b6" },
                { "index": 19, "owner": "13LrNQNfYo14i6w4wHJpq97VjEcm12Uuix", "txid": "23d777898c4be1b48b3af119f9517d0bd9efc4f5164c1979b416140414d5ab69" },
                { "index": 28, "owner": "17BU6J2bQUtf98nj3YP4L43aFhjCPAixDS", "txid": "72dd9af34257bbe9538fef3de169b387c3df87dc6c7d5c81ad2c6c7d67bc6217" },
                { "index": 39, "owner": "1H94vK88GPFEQ1kXN3zgkdM2sh5dxbUgAc", "txid": "5c3e2ec54837aa4f3c675ea95ecc8868abe341ecd30cde89ac6eae3880d29356" },
                { "index": 52, "owner": "1GBRAtCTNWfMkWQi969sNXTkiQN9S8S9gA", "txid": "eabd5967d5881719c2f022da36b86944e8348b785c0277a7d3c87b07479916b6" },
                { "index": 67, "owner": "19SCehgeuwbaaTDkWmkt3Qu6BhroeLfoKM", "txid": "5b67bc042441b862befc52b8ced3ede1b4035526a04db3880707cfbe2bcf597d" },
                { "index": 84, "owner": "13cRbBQ3SVj12pMsk1AE6jEp6kwCaoj1FW", "txid": "0ff185a3f554c110679fa76d924a650c93a707b0182d0996cfbc5fb3568ade37" },
                { "index": 20, "owner": "1PJ2UJkiWrP3KtEQi8TrGtaZquipDAGF4Q", "txid": "76b73f9f11b0809358919756296a2fde01c01c3d5bd6fa2518a9e49f5bb949c8" },
                { "index": 21, "owner": "1CRUGtrHJ1jugxy5kG6V1Bv7YgowXHSRru", "txid": "7fa27c8a3c9fc57940b8f13d3edde5e0c9cf0806cad92dbc76b1def6075dc1a3" },
                { "index": 22, "owner": "1KjNE68uihpR2efpL2MiezaCykcctQGjr6", "txid": "e3e446d3b087758a75556af1d6d112fad96eeb231204b158b0d2105146669942" },
                { "index": 23, "owner": "1DXEArxYN2UwPAmFjSMg6bjPpafXzS4nt2", "txid": "8779822d2619953a1c5f4300d968e3eb756c46385ec73a91c0abffe2de35f328" },
                { "index": 24, "owner": "1M1DDEbvcJCnmvLUVqSENWX7qTsVCAxrpc", "txid": "370d02c32ee97ba0969ed3b4ffe86c630780fd9ff35f5cb1dd72a3e99d03313f" },
                { "index": 29, "owner": "1KdhFc8fy73gCJEg6gnKaB6EEvr3Y5EYUt", "txid": "bf8f0d3d0e86fab3f390991c988adc87fcadcb4e0419df3c42d17a661deed092" },
                { "index": 40, "owner": "1Bo4cGSVfR1bL2ouz37AC2ktGri1wC6XZq", "txid": "94c836af70190b699ecb18cf259f1d35f18d998d551e22610a356255f309e38c" },
                { "index": 53, "owner": "1A6b7KHVLAFZTiaQXzNgBuSukg1TVEkBVe", "txid": "14fe261bc57d7146a00ec11a82e98c20e0998b4e8b7b8ffdf87db10dcffedb20" },
                { "index": 68, "owner": "1BcTViq9fDZ3NuFs5ahybk6PV8x2WD8STq", "txid": "92dafc70923bffb0e8a877d41a75ec1e4c9f0c5c834db6403ceec334fd6423a2" },
                { "index": 85, "owner": "158XKQ1KPNgHVNtENBRJq5YuNhzu7XEmyP", "txid": "771506e703e985720904298a96c03a065c731cc703d5d0689d677187427053ea" },
                { "index": 30, "owner": "1M7Pr2eMNUZxTS4PUHCzfiJaUBt1wmC4x7", "txid": "d71393d6f28cbde94042ce0444f38c78075adb67980c5ff706fbd2c87b0c398b" },
                { "index": 31, "owner": "1AWbrPfUzkZ47j1HjcoQBiMtiJCXM3m3bT", "txid": "7f6e1620c349f292b0cfbdc05b715b7191b1aadaa63dc71c12871f91dab26daf" },
                { "index": 32, "owner": "1FjJdKdn1jS7PYdn7uZf1UKp6zp1oYU2bG", "txid": "9228a475e2d9f15a4d7a6df837500372e16c2c16014923163b47146bb5e13cb8" },
                { "index": 33, "owner": "17hD2jMZFXp8w9Uu1anPQNHPBgQ6dRJvv", "txid": "a04d5916433207d74f0bd0c3045c1d983b68db00078672f4bbfebf4cb080e0c1" },
                { "index": 34, "owner": "1LxCnT7jg6eFE7SX9nBaNvTvmjDYeBWvp1", "txid": "1f554e896f8ab2550adecb155b39d010781fe90c1d78db08d00315f8eff22fd6" },
                { "index": 35, "owner": "168nPQmMDXHF4SKyEsrkyLsLiLspYFUB2c", "txid": "6906e7146502b74529d480492e4c6ae5043325b8db81922a6332f9c3130aea9c" },
                { "index": 41, "owner": "1PgG2sJPuZbB7dngMyJNfa7xvcjEHytRuf", "txid": "70cb53d58f7e2f30eef7baa750c611d648e6e91e17275c9b5f8152b1ae544955" },
                { "index": 54, "owner": "1DdfS4bGU2ciBAHA3mMnGGB1deAUxYgQkE", "txid": "95e85570156451bd13bd59f9e6b88d160a330394fe64730413c9d791d28d689c" },
                { "index": 69, "owner": "17chksZaUEvNUtMCMzFfyr5VhTJKb9XmY7", "txid": "b40307c2a717c63235975d48b2884ec94628f9e798812426fc3a23940d23cf06" },
                { "index": 86, "owner": "1cf2297m8f3wW5nCemiJNCUeEaMS27EBh", "txid": "d063f60c1877e9868c89e780e8780da95e3a807886aa5a70713e585030d2c0d3" },
                { "index": 42, "owner": "19j8sJASHckHjSp9Y6kDJFrYYo4S6qGN25", "txid": "92ae1e1d43731cad802eac2f7feb143a03352027133fc4b9162f4e3256791ccd" },
                { "index": 43, "owner": "1P1RkyvvZL4DzBzHsF6cBqAQPs9xsyBDxc", "txid": "2dbbd2f4ccfd7651ae10528266dd9f10b0adac2e8bed88eae37eeb6265a9d3df" },
                { "index": 44, "owner": "1J1Ph1MTpqv1ePA11Y94cuje7xtb11FsXN", "txid": "05417a4b11133101b1813ffc165cb2b5bd6080fd7d0c57f2224e5ab1a49858d5" },
                { "index": 45, "owner": "12Qr6dpJf9kHYFHaxGkjWCyqVCZTeuaH6k", "txid": "6f73f5f7a8d677d45ded898874db2cecaf9825aaea52c0c3393cfbf5526773fa" },
                { "index": 46, "owner": "1GJzCN2zbQ9ff5BuEsoYRHZA1Nkh2EzbdL", "txid": "672aa3e340fdf93972554fc8c074d9d1a079da301cdd506ffa73401970a7e477" },
                { "index": 47, "owner": "1HyALrfXKx5f1Z3329W1DCPWNKGEYLP81f", "txid": "0030af45022d3ca434229a9e823adcccdef4c2e36a3f0943d3a2082a7680d4b4" },
                { "index": 48, "owner": "16f1arM1pHLeRqDzYzmLhdDkGsa6y6V8Az", "txid": "bd3ee53f2fccba4ce535489f13b2b18755a94d783de9612ed58e70691272fc12" },
                { "index": 55, "owner": "14Xosjbj2aWzSe2WewZFwqL8yTDwTwKoVK", "txid": "10aca55ad2b614fc63e869f7b960215482c0e7db1cb0266a29ca43189e54b10d" },
                { "index": 70, "owner": "13EA3ZsXAvLm1iVWSNdieJvHqsxPm6yLVF", "txid": "491a0f7d023aeb946158885b50747c0256af496de9a8f02c3cc84fe31653b7f4" },
                { "index": 87, "owner": "12M1LdKNW3xRqCEppq5ocXRM4faQY7dp3F", "txid": "cd9f042b4b89bb0654d9a91f5695e51bbe6363cb746a29790642f0d4fa131ed6" },
                { "index": 56, "owner": "1AqpYMgqha8tBGXR97oqmE9SeHQ2KJd5eu", "txid": "40aa05026553aa59147cc2a43f2b466382bb5920f4cd7f3b5ba858fd3d689037" },
                { "index": 57, "owner": "19zDpKryAQKpSF2ecDSE5jWNNB6emyMmKY", "txid": "50cd547f46db42bda1196950375353d04a5a37afda3ca119906744cf466aeaa3" },
                { "index": 58, "owner": "1frDbfmrXe3RH34ZZtMdtnbFFMoMLQHKT", "txid": "2089266cbadba71f0c6e11be1dc1365613207fcebc23fb9eae7240b715159866" },
                { "index": 59, "owner": "1542h4odfsx3Z3FATUprff9kg3DUWRY6JG", "txid": "a98f4664af6502bf0c7886de160417c720fa94ca9b6b214a87541bd888bd2cbc" },
                { "index": 60, "owner": "1FrrMoJTuQMWGLMDX2XjXVm2mY8J6qr6xZ", "txid": "1204aff489248eb86bda99fa33ed24dd995ec27c4eb06931ca84896489be3608" },
                { "index": 61, "owner": "1HVakAyexqzpQiHiv61WW4A6BTcr95GoAk", "txid": "13dad978854b4d321f6f236ab942cbecc54ba31492ecd36580efdd19459afacf" },
                { "index": 62, "owner": "13DGmsrna6NQnU3afcFqdD6pjALixsBuGL", "txid": "65ea633052753d68225ed2d2fe5bc1714303b4989acde07107d8ded48b9dec31" },
                { "index": 63, "owner": "1FzRBK5KVWYRCJeRS1BBFpMDo7oDPS73uW", "txid": "740004efd42dda9f29550307c7b5fcf6e11099f19d9ee2e79037a731c0850887" },
                { "index": 71, "owner": "19h3oqUoaiYHhZ49PiTLiiWc17pqG3B3po", "txid": "9c116726c6a8a1614725a745b9f53e7df8b71a51f298815e344fa3dfa0bb9fd5" },
                { "index": 88, "owner": "13uvff2k2ZffHUpwmNTSB2jDaJv4zdXwyU", "txid": "92e12c7fa589b17baa5909d1a53f280f186611d9622031be61ea24104c4f984a" },
                { "index": 72, "owner": "1NaCmcvYcbEqn3zC6dS5G6fjU234zJpiXQ", "txid": "23b1cf331a23284633b9917266f2d6ed0ff9f61fd3462281e34280eb1b16a1ad" },
                { "index": 73, "owner": "19aiWc8MZpPXuMqj3P2NERr92H5sNQSc37", "txid": "72034dbc89b9ed2cc95d0ef2325ff75730588e033fa47a9282557ff6dd79e69e" },
                { "index": 74, "owner": "1GLJveLaeRGamegp9dNYWYFaVsdCrshF1", "txid": "ad68d1beda9d17516b5b39d6b72b032be17c73b07d7ee62d97943f8955423966" },
                { "index": 75, "owner": "13jfkpoSdJhDPsrdKE5Ked2hfrk2QKGk3s", "txid": "81e2cf060da88b0e6ea6d18a6a5ae0040624db3cfab99f7e0ad34570e7c5cdd5" },
                { "index": 76, "owner": "12LN5thjQzhJ557t7iYuEo72JLbwFGn7Xj", "txid": "52f2fa320e11decac377b5a1da2785cd8aec0ee965e1f506e9df4a55909befe0" },
                { "index": 77, "owner": "12mDjxo3eNq9R6fBQjBgFaVMRMaTCkupF6", "txid": "f8835bbbb72f03bbae7e8490da6ce71ecc9063863f265dc6ddbd4b7db5d01db0" },
                { "index": 78, "owner": "12gYMmfCQUfMeLdU4P9NwUid5hJTpgadVD", "txid": "68c17361a3ca98b00316ae8d04f965f6fb31c0a88637210d3c96b78e97af64ca" },
                { "index": 79, "owner": "1JtSNa67cjALeLUdMkXTtBxBsfWRWXKLEv", "txid": "bc4a015cbc460367b310e3223f8294b600c01633770ed613c9698be7a46631c3" },
                { "index": 80, "owner": "1Kmmpo7weiSCiR2qA9q7eEg8kTuRngz9iT", "txid": "b12a93e649c449e3787ef8b43e0233196bd833b821faa4aeaa307810b09dca7b" },
                { "index": 89, "owner": "1Lv9RoD1DDxKwTDsSBR9UWrm7eno6BLqiN", "txid": "b0f262b53c70a8b8003fb08d9c9bd4bb471f008a01f87203a28659094e0c3480" },
                { "index": 90, "owner": "17ZArK7x9sPDXimFfo7gTS3hM6HqkD8NAt", "txid": "20787d2da1eac97a542cdeb9e9c5ff16e713d2d30901c05fb5846e6e77d9674f" },
                { "index": 91, "owner": "1MBwECdiYBrg8R5QHSMmHrjzZDaxJarhBm", "txid": "91d79bb38e7d9a7a88e0c048ab3bb6d2d1d5d586627f2ab67ce910efbc12d027" },
                { "index": 92, "owner": "12phLoTu4qFoWZXmC689U9Kq7bJHuiSYxG", "txid": "79409120e3818a08da1b6a88164caae080b7529b83f08ded4c77d54d05821a61" },
                { "index": 93, "owner": "14pePBmcbCmQdZNTZwThTQdfRV4ETdvbmB", "txid": "e8451835e12213bcd9904b2a0d0ca04af11daeff73e19c68dfb79d09ef5c3cb0" },
                { "index": 94, "owner": "16USU3qqQGugAWJi4KZ9a42fSEZ2NqQLhk", "txid": "f6a1f5aa2ebe555b456e1515b467e0b53c06b520ed51367d4a2aa87e169d5e3c" },
                { "index": 95, "owner": "1LgbaF9h6jt47STCa9vtqFmHJvpk6C8BZT", "txid": "a110385bf4915a700dbb0c3999849aed89c90b94aaaeaf707190fc40ed587c0c" },
                { "index": 96, "owner": "1KenuAL2rSXeTMQ4N2u26sK9ZiRiDe3rMT", "txid": "937bf0a4446887e17709c22dc6fa182576e1a011d3f6a8621b8d3731dfb3e6e6" },
                { "index": 97, "owner": "14peLXTHZQeF2h9CnonyHv9d2hnLgWGsKa", "txid": "0a51ed6434b757627f66d381c9de0c83c1005919d8e2b2d1e57ff9357e453d5b" },
                { "index": 98, "owner": "1N6uDcVzYgRydf5tJERFQcV8Kn79hfW6tU", "txid": "91697cad9785c8f3412161c9e175c76806095e37bfe3d453295fba24d331ffb7" },
                { "index": 99, "owner": "1N7AWenHDXrAu7VK8hZ2AABoh31WLGJFCF", "txid": "f09b088f42fc36469ac2f2540fbf9f60c0e7296c7804cd70fd92a560414717f0" },
            ];

            plots = meta.map(m => ({
                index: m.index,
                owner: m.owner,
                genesisId: m.txid,
                headId: m.txid,
                instance: null,
                originalPixels: new Uint8Array(28 * 28).fill(0),
                modifiedIndices: new Set(),
                queuedRents: new Set() // Can select multiple quadrants (0-3)
            }));
        }

        async function loadGrid() {
            addLog("Syncing Grid...");

            // Phase 1: Center 3x3 (Plots 0-8)
            const centerPlots = plots.filter(p => p.index < 9);
            addLog(`Phase 1: Syncing Center 3x3 (${centerPlots.length} plots)...`);
            await syncSubset(centerPlots);
            addLog("Center 3x3 Ready!", "success");

            // Render what we have immediately
            drawGridOverlays();
            showRentedQuadrants();

            // Phase 2: Remaining plots (Plots 9-99)
            const extensionPlots = plots.filter(p => p.index >= 9);
            if (extensionPlots.length > 0) {
                addLog(`Phase 2: Syncing Extension (${extensionPlots.length} plots)...`);
                // Small delay to let UI breathe
                await new Promise(r => setTimeout(r, 100));
                await syncSubset(extensionPlots);
            }

            // Finalize
            await updateBlockHeight();
            drawGridOverlays();
            showRentedQuadrants();
            addLog("Grid Sync Complete!", "success");
        }

        async function syncSubset(targetPlots) {
            const { bsv, PixelPlot28 } = ScryptBundle;

            // 1. Resolve heads (Fast Spent Check)
            addLog(`Following chains for ${targetPlots.length} plots...`);
            const headIds = targetPlots.map(p => p.headId);
            const currentHeads = await fetchLatestTxidsBulk(headIds);
            console.log("Heads found:", currentHeads);
            targetPlots.forEach((p, i) => p.headId = currentHeads[i]);

            // 2. Fetch all transaction data in bulk
            addLog(`Fetching hex data...`);
            const txDataMap = await fetchBulkHexDirect(targetPlots.map(p => p.headId));
            console.log("Hex data keys count:", Object.keys(txDataMap).length);

            // 3. Process plots
            for (let i = 0; i < targetPlots.length; i++) {
                const plot = targetPlots[i];
                const hex = txDataMap[plot.headId];
                if (hex) {
                    try {
                        const cleanHex = (typeof hex === 'string') ? hex.trim() : (hex.hex || hex.tx_hex || "");
                        if (!cleanHex || cleanHex === "[object Object]") {
                            throw new Error(`Invalid hex type: ${typeof hex}`);
                        }

                        console.log(`Plot ${plot.index}: Parsing hex ${cleanHex.substring(0, 20)}...`);
                        const tx = new bsv.Transaction(cleanHex);
                        plot.instance = PixelPlot28.fromTx(tx, 0);

                        // Parse OP_RETURN comment
                        plot.lastComment = "";
                        for (const out of tx.outputs) {
                            if (out.script.isSafeDataOut()) {
                                const data = out.script.chunks[1].buf?.toString('utf8') || "";
                                if (data) {
                                    plot.lastOpReturn = data;
                                    if (data.includes('|')) {
                                        plot.lastComment = data.split('|')[1].trim();
                                    }
                                }
                                break;
                            }
                        }

                        if (plot.instance) {
                            decodePlotState(plot, false);
                        } else {
                            throw new Error("instance is null after fromTx");
                        }
                    } catch (e) {
                        console.error(`Plot ${plot.index} Parse Error:`, e);
                        addLog(`Plot ${plot.index} Error: ${e.message}`, "error");
                    }
                } else {
                    console.warn(`Zero hex for plot ${plot.index}`);
                }
            }
        }

        async function fetchLatestTxidsBulk(txids) {
            addLog(`Following ${txids.length} txids (bulk)...`);
            let current = [...txids];
            let finished = new Array(txids.length).fill(false);

            for (let iter = 0; iter < 50; iter++) {
                const toCheck = [];
                const checkIndices = [];
                for (let i = 0; i < current.length; i++) {
                    const id = current[i];
                    if (!finished[i] && id && id.length === 64) {
                        toCheck.push({ txid: id, vout: 0 });
                        checkIndices.push(i);
                    } else if (!finished[i]) {
                        finished[i] = true;
                    }
                }

                if (toCheck.length === 0) {
                    console.log("No more txids to check.");
                    break;
                }

                console.log(`Iteration ${iter}: Checking ${toCheck.length} txids...`);
                addLog(`Loop ${iter}: Checking ${toCheck.length} txids...`);
                // Batch the spent check (Whatsonchain limit is 20)
                let madeProgressInIter = false;
                const promises = [];
                for (let b = 0; b < toCheck.length; b += 20) {
                    const batch = toCheck.slice(b, b + 20);
                    const batchIndices = checkIndices.slice(b, b + 20);
                    promises.push((async () => {
                        try {
                            const targetUrl = 'https://api.whatsonchain.com/v1/bsv/main/utxos/spent';
                            const resp = await fetch(`/api/proxy?url=${encodeURIComponent(targetUrl)}`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ utxos: batch })
                            });

                            if (!resp.ok) return;

                            const data = await resp.json();
                            data.forEach((item, idx) => {
                                const originalIdx = batchIndices[idx];
                                if (item.spentIn && (item.spentIn.txid || item.spentIn.tx_hash)) {
                                    current[originalIdx] = item.spentIn.txid || item.spentIn.tx_hash;
                                    madeProgressInIter = true;
                                } else {
                                    finished[originalIdx] = true;
                                }
                            });
                        } catch (e) {
                            console.error("Spent check error:", e);
                        }
                    })());
                }
                await Promise.all(promises);
                if (!madeProgressInIter) break;
            }
            console.log("Sync loop finished. Final Heads:", current);
            return current;
        }

        async function fetchBulkHexDirect(txids) {
            const cleanIds = [...new Set(txids.filter(id => id && id.length === 64))];
            if (cleanIds.length === 0) return {};

            addLog(`Fetching ${cleanIds.length} HEXs (chunked)...`);
            const map = {};
            const chunkSize = 20;

            try {
                const promises = [];
                for (let i = 0; i < cleanIds.length; i += chunkSize) {
                    const chunk = cleanIds.slice(i, i + chunkSize);
                    promises.push((async () => {
                        const targetUrl = 'https://api.whatsonchain.com/v1/bsv/main/txs/hex';
                        const resp = await fetch(`/api/proxy?url=${encodeURIComponent(targetUrl)}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ txids: chunk })
                        });

                        if (!resp.ok) {
                            console.error(`Chunk fetch failed: ${resp.status}`);
                            return;
                        }

                        const data = await resp.json();
                        chunk.forEach((txid, idx) => {
                            const item = data[idx];
                            if (item) {
                                if (typeof item === 'string') {
                                    map[txid] = item;
                                } else if (item.hex) {
                                    map[txid] = item.hex;
                                }
                            }
                        });
                    })());
                }
                await Promise.all(promises);
                addLog(`Received ${Object.keys(map).length} hexes total.`);
            } catch (e) {
                console.error("Bulk fetch failed:", e);
            }
            return map;
        }



        async function fetchBulkSpent(utxos) {
            // Unused in main path, but nice to have. Converted to individual checks?
            // Actually this is unused by current logic, let's just make it return empty to save space or mimic behavior.
            const results = await Promise.all(utxos.map(async u => {
                const url = `https://api.whatsonchain.com/v1/bsv/main/tx/${u.txid}/out/${u.vout}/spent`;
                const res = await fetch(`/api/proxy?url=${encodeURIComponent(url)}&t=${Date.now()}`);
                if (res.ok) return res.json();
                return {};
            }));
            return results;
        }

        function drawGridOverlays() {
            const overlay = document.getElementById('quadrant-overlay');
            overlay.innerHTML = '';
            const pixelSize = 5;

            // 1. Draw Plot Boundaries (7x7 grid - every 28 pixels)
            for (let i = 1; i < 10; i++) {
                const pos = i * 28 * pixelSize;

                // Horizontal Plot Line
                const hLine = document.createElement('div');
                hLine.className = 'plot-grid-line';
                hLine.style.cssText = `position:absolute; top:${pos}px; left:0; right:0; height:2px; background:rgba(255,255,255,0.3); pointer-events:none; z-index:21;`;
                overlay.appendChild(hLine);

                // Vertical Plot Line
                const vLine = document.createElement('div');
                vLine.className = 'plot-grid-line';
                vLine.style.cssText = `position:absolute; left:${pos}px; top:0; bottom:0; width:2px; background:rgba(255,255,255,0.3); pointer-events:none; z-index:21;`;
                overlay.appendChild(vLine);
            }

            // 2. Draw Quadrant Subdivisions (2x2 within each plot - every 14 pixels)
            // 10 plots * 2 quadrants = 20 quadrants per row/col.
            // But we can just iterate every 14 pixels * pixelSize
            // Total grid size 280 pixels. 280/14 = 20.
            // So lines at 14, 42, 70, 98, 126, 154, 182
            const quadLines = [];
            for (let i = 1; i < 20; i++) quadLines.push(i * 14);
            quadLines.forEach(p => {
                const pos = p * pixelSize;
                // Horizontal Quadrant Line
                const hLine = document.createElement('div');
                hLine.className = 'quadrant-grid-line';
                hLine.style.cssText = `position:absolute; top:${pos}px; left:0; right:0; height:1px; background:rgba(255,255,255,0.1); pointer-events:none; z-index:20;`;
                overlay.appendChild(hLine);

                // Vertical Quadrant Line
                const vLine = document.createElement('div');
                vLine.className = 'quadrant-grid-line';
                vLine.style.cssText = `position:absolute; left:${pos}px; top:0; bottom:0; width:1px; background:rgba(255,255,255,0.1); pointer-events:none; z-index:20;`;
                overlay.appendChild(vLine);
            });
        }

        async function syncPlot(plot) {
            const { PixelPlot28, bsv } = ScryptBundle;
            try {
                const provider = await getProvider();
                const wif = getWif();
                const addr = bsv.PrivateKey.fromWIF(wif).toAddress().toString();

                const headId = await findHead(plot.genesisId, 0, addr);
                plot.headId = headId;

                const tx = await provider.getTransaction(headId);
                plot.instance = PixelPlot28.fromTx(tx, 0);

                decodePlotState(plot, true);
            } catch (e) {
                addLog(`Plot ${plot.index} sync failed: ${e.message}`, "error");
            }
        }



        function initPalette() {
            const container = document.getElementById('palette');

            // Add Hand Tool
            const handDiv = document.createElement('div');
            handDiv.className = 'swatch selected';
            handDiv.id = 'swatch-hand';
            handDiv.innerHTML = '<div style="font-size: 16px; display: flex; align-items: center; justify-content: center; height: 100%;">✋</div>';
            handDiv.style.background = '#1e293b';
            handDiv.title = 'Pan / Drag Tool';
            handDiv.onclick = selectHand;
            container.appendChild(handDiv);

            COLORS.forEach((c, i) => {
                const div = document.createElement('div');
                div.className = 'swatch color-swatch';
                div.style.backgroundColor = c;
                div.onclick = () => selectColor(i);
                container.appendChild(div);
            });
        }

        // Canvas Context
        let ctx = null;

        function initGrid() {
            const container = document.getElementById('grid');
            container.innerHTML = ''; // Clear existing
            // CSS handles grid layout, remove grid-template-columns style
            container.style.display = 'block';

            const canvas = document.createElement('canvas');
            canvas.id = 'grid-canvas';
            canvas.width = 280;
            canvas.height = 280;
            // Scale up with CSS to match pixel-size (5px per pixel)
            canvas.style.width = (280 * 5) + 'px';
            canvas.style.height = (280 * 5) + 'px';
            canvas.style.imageRendering = 'pixelated'; // Crisp pixels

            container.appendChild(canvas);
            ctx = canvas.getContext('2d', { alpha: false }); // No transparency needed = faster

            // Initialize white background
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, 280, 280);

            // Interaction Overlay (for events) or bind directly to canvas?
            // Binding to container/viewport catches events, but mapping needs to be precise.
            // Let's attach to canvas.
            // Note: Pan/Zoom happens on #grid-container which contains #grid.
            // Event coordinates need to account for this.

            setupCanvasInteractions();
            window.addEventListener('mouseup', () => isDrawing = false);
        }

        function getPixelIndexFromEvent(e) {
            const rect = document.getElementById('grid-canvas').getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const pixelX = Math.floor(x / (rect.width / 280));
            const pixelY = Math.floor(y / (rect.height / 280));

            if (pixelX < 0 || pixelX >= 280 || pixelY < 0 || pixelY >= 280) return -1;
            return pixelY * 280 + pixelX;
        }

        // --- Replacing Interaction Handlers ---
        // Bind these in setupEventListeners() or ensure called after initGrid

        function setupCanvasInteractions() {
            const canvas = document.getElementById('grid-canvas');
            const container = document.getElementById('grid-container');

            const handlePaintStart = (e, clientX, clientY) => {
                if (selectedTool === 'hand') {
                    isPanning = true;
                    lastMouseX = clientX;
                    lastMouseY = clientY;
                    container.style.cursor = 'grabbing';
                    return;
                }

                const idx = getPixelIndexFromEvent(e, clientX, clientY);
                if (idx === -1) return;

                if (currentMode === 'paint') {
                    isDrawing = true; paint(idx);
                } else {
                    handleRentClick(idx);
                }
            };

            const handlePaintMove = (e, clientX, clientY) => {
                if (selectedTool === 'hand' && isPanning) {
                    // Panning is handled by window.onmousemove in initPanZoom
                    return;
                }

                const idx = getPixelIndexFromEvent(e, clientX, clientY);
                if (idx !== -1) {
                    if (isDrawing && currentMode === 'paint') {
                        paint(idx);
                    }
                    updateHoverInfo(idx);
                }
            };

            canvas.onmousedown = (e) => {
                if (e.button === 0) { // Left click
                    handlePaintStart(e, e.clientX, e.clientY);
                }
            };

            canvas.onmousemove = (e) => {
                handlePaintMove(e, e.clientX, e.clientY);
            };

            // Touch Painting / Panning
            canvas.ontouchstart = (e) => {
                if (e.touches.length === 1) {
                    const t = e.touches[0];
                    handlePaintStart(e, t.clientX, t.clientY);
                    // Always prevent default if we're in color mode (drawing) or hand mode (panning via our own logic)
                    e.preventDefault();
                }
            };

            canvas.ontouchmove = (e) => {
                if (e.touches.length === 1) {
                    const t = e.touches[0];
                    if (isPanning) {
                        const dx = t.clientX - lastMouseX;
                        const dy = t.clientY - lastMouseY;
                        panX += dx;
                        panY += dy;
                        lastMouseX = t.clientX;
                        lastMouseY = t.clientY;
                        updateTransform();
                    } else if (isDrawing) {
                        handlePaintMove(e, t.clientX, t.clientY);
                    }
                    e.preventDefault();
                }
            };

            canvas.ontouchend = () => {
                isDrawing = false;
                isPanning = false;
                container.style.cursor = 'grab';
            };
        }

        // Updated helper to handle client coords
        function getPixelIndexFromEvent(e, clientX, clientY) {
            const canvas = document.getElementById('grid-canvas');
            if (!canvas) return -1;
            const rect = canvas.getBoundingClientRect();

            // If they didn't provide coords, use from event (legacy fallback)
            const cx = clientX !== undefined ? clientX : e.clientX;
            const cy = clientY !== undefined ? clientY : e.clientY;

            const x = cx - rect.left;
            const y = cy - rect.top;

            // Normalized to grid size (280)
            const pixelX = Math.floor(x / (rect.width / 280));
            const pixelY = Math.floor(y / (rect.height / 280));

            if (pixelX < 0 || pixelX >= 280 || pixelY < 0 || pixelY >= 280) return -1;
            return pixelY * 280 + pixelX;
        }

        function redrawGrid() {
            if (!ctx) return;
            const imageData = ctx.createImageData(280, 280);
            const data = imageData.data;

            // Fill imageData from currentPixels
            for (let i = 0; i < 280 * 280; i++) {
                const colorIdx = currentPixels[i];
                const hex = COLORS[colorIdx] || '#FFFFFF';
                // Convert hex to rgb
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);

                const pos = i * 4;
                data[pos] = r;
                data[pos + 1] = g;
                data[pos + 2] = b;
                data[pos + 3] = 255; // Alpha
            }
            ctx.putImageData(imageData, 0, 0);

            // Re-apply overlays (rent highlights etc)
            // Ideally these are on a separate canvas layer or div overlays
            // Currently overlays are separate divs in #quadrant-overlay which sits ON TOP.
            // So we don't need to draw grid lines or rent markers on the pixel canvas!
            // BUT 'is-filled' class on pixels was used for styling.
            // And 'rent-selected' class was used for styling.
            // We need to replicate visual cues for rent selection canvas-side OR use a simplified overlay system.

            // For now: Selection is easier with an SVG or Canvas overlay. 
            // Let's assume selection highlights are handled by 'drawSelectionOverlay' which we might need to add,
            // or simply tint the pixels in the main canvas.
            // Actually, `highlightQuadrant` adds classes to divs. We don't have divs anymore.
            // We need to implement `drawHighlights()`
            drawHighlights();
        }

        function drawHighlights() {
            // Rent selections
            // Iterate all plots, check queued rents
            // Draw transparent rects

            // We can draw directly on top of the pixels in the same context?
            // Or better: use the existing #quadrant-overlay for this?
            // The existing overlay has grid lines. We can add selection boxes there.
            // Simpler: Just darken pixels in the pixel canvas? No, that modifies pixel data.
            // Let's use a secondary canvas for UI highlights or append divs to the overlay layer.

            // Let's stick to appending divs to #quadrant-overlay for selections as it's cleaner than modifying currentPixels buffer
            updateSelectionOverlay();
        }

        function updateSelectionOverlay() {
            // Clear previous selections from overlay (except grid lines)
            const overlay = document.getElementById('quadrant-overlay');
            // Remove old selection/rented rects
            overlay.querySelectorAll('.selection-rect, .rented-rect').forEach(e => e.remove());

            plots.forEach(plot => {
                // Draw Active Rents (From Contract)
                if (plot.activeRents) {
                    plot.activeRents.forEach(rent => {
                        const r = getQuadrantRect(plot, rent.qIdx);
                        const div = document.createElement('div');
                        div.className = 'rented-rect';
                        div.style.left = r.x + 'px';
                        div.style.top = r.y + 'px';
                        div.style.width = r.w + 'px';
                        div.style.height = r.h + 'px';

                        let html = `<span style="position:absolute;bottom:2px;right:2px;color:lime;font-size:8px;text-shadow:0 1px 2px #000;">✓</span>`;
                        if (rent.comment) {
                            html += `<div style="position:absolute;top:2px;left:2px;right:2px;font-size:5px;color:white;background:rgba(0,0,0,0.6);padding:1px 2px;border-radius:2px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:90%; border:0.5px solid rgba(255,255,255,0.2);">${rent.comment}</div>`;
                        } else {
                            html += `<div style="position:absolute;top:2px;left:2px;font-size:5px;color:rgba(255,255,255,0.5);">${rent.blocksLeft} BLK</div>`;
                        }
                        div.innerHTML = html;
                        overlay.appendChild(div);
                    });
                }

                // Draw Queued Rents (User Selection)
                plot.queuedRents.forEach(qIdx => {
                    const r = getQuadrantRect(plot, qIdx);
                    // Don't draw selection over active rent (optional)
                    const div = document.createElement('div');
                    div.className = 'selection-rect';
                    div.style.left = r.x + 'px';
                    div.style.top = r.y + 'px';
                    div.style.width = r.w + 'px';
                    div.style.height = r.h + 'px';
                    overlay.appendChild(div);
                });
            });
        }

        function getQuadrantRect(plot, qIdx) {
            const gridIdx = plots.indexOf(plot);
            const plotRow = Math.floor(gridIdx / 10);
            const plotCol = gridIdx % 10;
            const qRow = Math.floor(qIdx / 2);
            const qCol = qIdx % 2;

            // Pixel scale is 5
            const x = (plotCol * 28 + qCol * 14) * 5;
            const y = (plotRow * 28 + qRow * 14) * 5;
            return { x, y, w: 14 * 5, h: 14 * 5 };
        }

        // --- Updated Paint ---
        function paint(globalIdx) {
            if (currentPixels[globalIdx] === selectedColor) return;
            currentPixels[globalIdx] = selectedColor;

            // Update Canvas directly for speed
            if (ctx) {
                const hex = COLORS[selectedColor];
                ctx.fillStyle = hex;
                // x, y index
                const y = Math.floor(globalIdx / 280);
                const x = globalIdx % 280;
                ctx.fillRect(x, y, 1, 1);
            }

            // Logic
            const y = Math.floor(globalIdx / 280);
            const x = globalIdx % 280;
            const plotRow = Math.floor(y / 28);
            const plotCol = Math.floor(x / 28);
            const plotIdx = plotRow * 10 + plotCol;
            const plot = plots[plotIdx];

            const localY = y % 28;
            const localX = x % 28;
            const localIdx = localY * 28 + localX;

            if (!plot.modifiedIndices.has(localIdx)) {
                plot.modifiedIndices.add(localIdx);
            }
            updateQueueUI();
        }

        // --- Updated Decode ---
        function decodePlotState(plot, resetEdits = true) {
            if (!plot.instance || !plot.instance.pixels) {
                console.warn(`Plot ${plot.index} has no instance data.`);
                return;
            }
            // Use .pixels directly if it's already a string, or toHex if it's a ByteString object
            const pixelsVal = typeof plot.instance.pixels === 'string' ? plot.instance.pixels :
                (plot.instance.pixels.toHex ? plot.instance.pixels.toHex() : plot.instance.pixels.toString());

            const rawHex = pixelsVal.startsWith('0x') ? pixelsVal.slice(2) : pixelsVal;

            if (rawHex.length < 980) {
                console.warn(`Plot ${plot.index} pixels data too short: ${rawHex.length} chars`);
            }

            let n = 0n;
            for (let i = 0; i < rawHex.length; i += 2) {
                const byte = BigInt(parseInt(rawHex.substr(i, 2), 16) || 0);
                n |= (byte << (BigInt(i / 2) * 8n));
            }

            for (let i = 0; i < 784; i++) {
                const color = Number((n >> (BigInt(i) * 5n)) & 31n);
                plot.originalPixels[i] = color;

                const globalIdx = getGlobalIdxFromLocal(plot, i);
                if (resetEdits || !plot.modifiedIndices.has(i)) {
                    currentPixels[globalIdx] = color;
                }
            }
            if (resetEdits) {
                plot.modifiedIndices.clear();
            }
            // Trigger redraw
            requestAnimationFrame(redrawGrid);
            updateQueueUI();
        }

        function updateHoverInfo(globalIdx) {
            const y = Math.floor(globalIdx / 280);
            const x = globalIdx % 280;
            const plotRow = Math.floor(y / 28);
            const plotCol = Math.floor(x / 28);
            const plotIdx = plotRow * 10 + plotCol;

            const localY = y % 28;
            const localX = x % 28;
            const qX = Math.floor(localX / 14);
            const qY = Math.floor(localY / 14);
            const qIdx = qY * 2 + qX;

            document.getElementById('plot-info-card').innerHTML = `
                <div style="color:var(--accent); font-weight:600">PLOT ${plotIdx}</div>
                <div>X: ${x}, Y: ${y}</div>
                <div>Quadrant: Q${qIdx}</div>
            `;
        }

        function initPanZoom() {
            const container = document.getElementById('grid-container');
            const viewport = document.querySelector('.viewport');

            viewport.onwheel = (e) => {
                e.preventDefault();
                const zoomSpeed = 0.001;
                const delta = -e.deltaY * zoomSpeed;
                const oldScale = scale;
                scale = Math.min(Math.max(0.1, scale + scale * delta), 15);

                const vRect = viewport.getBoundingClientRect();
                const mouseX = e.clientX - vRect.left;
                const mouseY = e.clientY - vRect.top;

                const scaleRatio = scale / oldScale;
                panX = mouseX - (mouseX - panX) * scaleRatio;
                panY = mouseY - (mouseY - panY) * scaleRatio;

                updateTransform();
            };

            // --- TOUCH SUPPORT ---
            let initialDist = 0;
            let initialScale = 1;

            viewport.ontouchstart = (e) => {
                if (e.touches.length === 2) {
                    initialDist = Math.hypot(
                        e.touches[0].pageX - e.touches[1].pageX,
                        e.touches[0].pageY - e.touches[1].pageY
                    );
                    initialScale = scale;
                    document.getElementById('bottom-shelf').classList.add('locked-interaction');
                    e.preventDefault();
                } else if (e.touches.length === 1) {
                    isPanning = true;
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                }
            };

            viewport.ontouchmove = (e) => {
                if (e.touches.length === 2) {
                    const dist = Math.hypot(
                        e.touches[0].pageX - e.touches[1].pageX,
                        e.touches[0].pageY - e.touches[1].pageY
                    );
                    const delta = dist / initialDist;
                    const oldScale = scale;
                    scale = Math.min(Math.max(0.1, initialScale * delta), 15);

                    const vRect = viewport.getBoundingClientRect();
                    const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - vRect.left;
                    const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - vRect.top;

                    const scaleRatio = scale / oldScale;
                    panX = centerX - (centerX - panX) * scaleRatio;
                    panY = centerY - (centerY - panY) * scaleRatio;

                    updateTransform();
                    e.preventDefault();
                } else if (e.touches.length === 1 && isPanning) {
                    const dx = e.touches[0].clientX - lastMouseX;
                    const dy = e.touches[0].clientY - lastMouseY;
                    panX += dx;
                    panY += dy;
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                    updateTransform();
                }
            };

            viewport.ontouchend = () => {
                isPanning = false;
                document.getElementById('bottom-shelf').classList.remove('locked-interaction');
            };

            viewport.onmousedown = (e) => {
                if (e.button === 2 || e.button === 1) { // Right or Middle click
                    isPanning = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    container.style.cursor = 'grabbing';
                    e.preventDefault();
                }
            };

            window.onmousemove = (e) => {
                if (isPanning) {
                    const dx = e.clientX - lastMouseX;
                    const dy = e.clientY - lastMouseY;
                    panX += dx;
                    panY += dy;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    updateTransform();
                }
            };

            window.onmouseup = () => {
                isPanning = false;
                container.style.cursor = 'grab';
            };

            viewport.oncontextmenu = (e) => e.preventDefault();
        }

        function handleSliderZoom(val) {
            const newVal = parseFloat(val);
            const viewport = document.querySelector('.viewport');
            const vRect = viewport.getBoundingClientRect();
            const centerX = vRect.width / 2;
            const centerY = vRect.height / 2;

            const oldScale = scale;
            scale = newVal;

            const scaleRatio = scale / oldScale;
            panX = centerX - (centerX - panX) * scaleRatio;
            panY = centerY - (centerY - panY) * scaleRatio;

            updateTransform();
        }

        function toggleShelf() {
            document.getElementById('bottom-shelf').classList.toggle('collapsed');
        }

        function showZoomWarning() {
            const el = document.getElementById('zoom-warning');
            el.style.opacity = '1';
            setTimeout(() => el.style.opacity = '0', 2000);
        }

        function updateTransform() {
            const container = document.getElementById('grid-container');
            const slider = document.getElementById('zoom-range');
            const sliderVal = document.getElementById('zoom-value');

            if (slider) slider.value = scale;
            if (sliderVal) sliderVal.innerText = `${scale.toFixed(1)}x`;

            requestAnimationFrame(() => {
                container.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
            });
        }

        // --- UI ACTIONS ---
        function setMode(mode) {
            // Stop history playback if leaving history mode
            if (currentMode === 'history' && mode !== 'history') {
                historyStop();
                restoreFromHistory();
            }

            currentMode = mode;
            document.getElementById('paint-mode-btn').classList.toggle('active', mode === 'paint');
            document.getElementById('rent-mode-btn').classList.toggle('active', mode === 'rent');
            document.getElementById('history-mode-btn').classList.toggle('active', mode === 'history');
            document.getElementById('rent-options').style.display = mode === 'rent' ? 'block' : 'none';
            document.getElementById('history-options').style.display = mode === 'history' ? 'block' : 'none';
            document.body.classList.toggle('rent-mode', mode === 'rent');
            document.body.classList.toggle('history-mode', mode === 'history');

            // Clear rent selections when switching to paint
            if (mode === 'paint') {
                clearRentSelections();
                clearRentedDisplay();
            }

            // Show rented quadrants when entering rent mode
            if (mode === 'rent') {
                setTimeout(() => showRentedQuadrants(), 50);
            }

            // Hide palette card if not in paint mode
            const paletteCard = document.getElementById('palette-card');
            if (paletteCard) paletteCard.style.display = mode === 'paint' ? 'block' : 'none';

            updateQueueUI();
            setTool(selectedTool);
            addLog(`Switched to ${mode.toUpperCase()} mode.`);
        }

        function setRentPeriod(blocks) {
            rentPeriod = blocks;
            document.querySelectorAll('.rent-period-btn').forEach(btn => {
                const btnBlocks = {
                    '6 blk': 6,
                    '36 blk': 36,
                    '1 day': 144,
                    '1 week': 1008
                }[btn.textContent.trim()];
                btn.classList.toggle('active', btnBlocks === blocks);
            });
            const labels = { 6: '~1hr', 36: '~6hrs', 144: '~1 day', 1008: '~1 week' };
            addLog(`Rent period: ${blocks} blocks (${labels[blocks] || blocks + ' blocks'})`);
        }

        function clearRentSelections() {
            document.querySelectorAll('.pixel.rent-selected').forEach(el => {
                el.classList.remove('rent-selected');
            });
            plots.forEach(plot => plot.queuedRents.clear());
            hideRentInfo();
        }

        function zoomToPlot(plotIdx) {
            const plot = plots[plotIdx];
            const plotRow = Math.floor(plotIdx / 10);
            const plotCol = plotIdx % 10;

            const viewport = document.querySelector('.viewport');
            const vRect = viewport.getBoundingClientRect();

            // Calculate center of plot in grid coordinates
            const pixelSize = 5; // var(--pixel-size)
            const plotCenterX = (plotCol * 28 + 14) * pixelSize;
            const plotCenterY = (plotRow * 28 + 14) * pixelSize;

            // Zoom in and center on plot
            scale = 4;
            panX = (vRect.width / 2) - (plotCenterX * scale);
            panY = (vRect.height / 2) - (plotCenterY * scale);

            updateTransform();
            addLog(`Zoomed to Plot ${plotIdx}`);
        }

        function updateFeeLabel(val) {
            feeRate = parseInt(val);
            document.getElementById('fee-val').innerText = val;
            addLog(`Fee rate: ${val} sat/kb (${(val / 1000).toFixed(2)} sat/byte)`);
        }

        function selectColor(idx) {
            selectedColor = idx;
            setTool('color');
            addLog(`Switched color to #${idx}`);
        }

        function selectHand() {
            setTool('hand');
        }

        function setTool(tool) {
            selectedTool = tool;

            // Sync Palette UI (Paint mode)
            document.querySelectorAll('.swatch').forEach(s => s.classList.remove('selected'));
            if (tool === 'hand') {
                const h = document.getElementById('swatch-hand');
                if (h) h.classList.add('selected');
            } else {
                // Default action for color mode
                const sw = document.querySelectorAll('.color-swatch');
                if (sw[selectedColor]) sw[selectedColor].classList.add('selected');
            }

            // Sync Rent Tool UI
            const rHand = document.getElementById('rent-tool-hand');
            const rSelect = document.getElementById('rent-tool-interact');
            if (rHand && rSelect) {
                rHand.classList.toggle('active', tool === 'hand');
                rSelect.classList.toggle('active', tool !== 'hand');
            }

            // Sync History Tool UI
            const hHand = document.getElementById('history-tool-hand');
            const hSelect = document.getElementById('history-tool-interact');
            if (hHand && hSelect) {
                hHand.classList.toggle('active', tool === 'hand');
                hSelect.classList.toggle('active', tool !== 'hand');
            }

            updatePriceLabel();
        }

        function updatePriceLabel() {
            let price = (selectedColor <= 1) ? 1 : (selectedColor >= 28 ? 5 : 3);
            const el = document.getElementById('selected-price');
            if (el) el.innerText = (selectedTool === 'hand') ? "DRAG MODE" : `${price} SAT / PIXEL`;
        }

        // --- CANAVAS & INTERACTION UPDATES ---

        function paint(globalIdx) {
            if (currentPixels[globalIdx] === selectedColor) return;
            currentPixels[globalIdx] = selectedColor;

            // 1. Update Canvas directly for speed
            if (ctx) {
                const hex = COLORS[selectedColor];
                ctx.fillStyle = hex;
                const y = Math.floor(globalIdx / 280);
                const x = globalIdx % 280;
                ctx.fillRect(x, y, 1, 1);
            }

            // 2. Logic & State
            const y = Math.floor(globalIdx / 280);
            const x = globalIdx % 280;
            const plotRow = Math.floor(y / 28);
            const plotCol = Math.floor(x / 28);
            const plotIdx = plotRow * 10 + plotCol;
            const plot = plots[plotIdx];

            const localY = y % 28;
            const localX = x % 28;
            const localIdx = localY * 28 + localX;

            // Check against original to toggle 'modified' state
            if (currentPixels[globalIdx] !== plot.originalPixels[localIdx]) {
                plot.modifiedIndices.add(localIdx);
            } else {
                plot.modifiedIndices.delete(localIdx);
            }
            updateQueueUI();
        }

        function handleRentClick(globalIdx) {
            const y = Math.floor(globalIdx / 280);
            const x = globalIdx % 280;
            const plotRow = Math.floor(y / 28);
            const plotCol = Math.floor(x / 28);
            const plotIdx = plotRow * 10 + plotCol;
            const plot = plots[plotIdx];

            const localY = y % 28;
            const localX = x % 28;
            const qX = Math.floor(localX / 14);
            const qY = Math.floor(localY / 14);
            const qIdx = qY * 2 + qX;

            // Toggle quadrant selection
            if (plot.queuedRents.has(qIdx)) {
                plot.queuedRents.delete(qIdx);
                addLog(`Removed Q${qIdx} from Plot ${plotIdx}`);
            } else {
                plot.queuedRents.add(qIdx);
                addLog(`Added Q${qIdx} to Plot ${plotIdx} (${rentPeriod} blocks)`);
            }

            // Update visuals
            updateSelectionOverlay();
            updateQueueUI();

            // Show rent info popup (Canvas version)
            showRentInfo(plotIdx, globalIdx);
        }

        function clearRentSelections() {
            plots.forEach(plot => plot.queuedRents.clear());
            updateSelectionOverlay();
            hideRentInfo();
        }

        function showRentInfo(plotIdx, nearGlobalIdx) {
            hideRentInfo();
            const plot = plots[plotIdx];
            if (!plot.instance) return;

            const popup = document.createElement('div');
            popup.className = 'rent-info-popup';
            popup.id = 'rent-info-popup';

            const rentPrice = plot.instance.rentPricePerBlock || 100n;
            const totalCost = BigInt(rentPeriod) * rentPrice * BigInt(Math.max(1, plot.queuedRents.size));

            popup.innerHTML = `
                <h4>Plot ${plotIdx} Rent Info</h4>
                <div class="info-row"><span>Price/block:</span> <span class="val">${rentPrice} sat</span></div>
                <div class="info-row"><span>Period:</span> <span class="val">${rentPeriod} blocks</span></div>
                <div class="info-row"><span>Selected:</span> <span class="val">${plot.queuedRents.size} quadrant(s)</span></div>
                <div class="info-row"><span>Total cost:</span> <span class="val">${totalCost} sat</span></div>
            `;

            const canvas = document.getElementById('grid-canvas');
            if (canvas) {
                const cRect = canvas.getBoundingClientRect();
                const y = Math.floor(nearGlobalIdx / 280);
                const x = nearGlobalIdx % 280;
                const pixelW = cRect.width / 280;
                const pixelH = cRect.height / 280;
                const screenX = cRect.left + x * pixelW;
                const screenY = cRect.top + y * pixelH;

                popup.style.left = Math.min(screenX + 20, window.innerWidth - 200) + 'px';
                popup.style.top = Math.max(screenY - 50, 10) + 'px';
                document.body.appendChild(popup);
                rentInfoPopup = popup;
            }

            setTimeout(() => {
                if (rentInfoPopup === popup) hideRentInfo();
            }, 3000);
        }

        function hideRentInfo() {
            if (rentInfoPopup) {
                rentInfoPopup.remove();
                rentInfoPopup = null;
            }
        }

        function showRentedQuadrants() {
            plots.forEach(plot => {
                plot.activeRents = [];
                if (!plot.instance || !plot.instance.rentEnds) return;
                for (let q = 0; q < 4; q++) {
                    const exp = Number(plot.instance.rentEnds[q]);
                    if (exp > currentBlockHeight) {
                        let comment = "";
                        // If the head transaction was a rent for this specific quadrant, show its comment
                        if (plot.lastOpReturn && plot.lastOpReturn.startsWith(`RENT_Q${q}_`)) {
                            comment = plot.lastComment || "";
                        }
                        plot.activeRents.push({
                            qIdx: q,
                            blocksLeft: exp - currentBlockHeight,
                            comment: comment
                        });
                    }
                }
            });
            updateSelectionOverlay();
        }

        function clearRentedDisplay() {
            plots.forEach(p => p.activeRents = []);
            updateSelectionOverlay();
        }

        // --- HISTORY MODE ---
        async function loadHistory(limit = 50, startBlock = null, endBlock = null) {
            addLog(`Loading history (${limit} txs, blocks: ${startBlock || 'any'}-${endBlock || 'any'})...`);
            historyEvents = [];

            // Try to load from cache first
            const cacheKey = `pixel_history_${plots[0].genesisId}`;
            const cached = localStorage.getItem(cacheKey);
            if (cached) {
                try {
                    const cachedEvents = JSON.parse(cached);
                    historyEvents = cachedEvents.map(ev => ({
                        ...ev,
                        time: new Date(ev.time),
                        pixels: new Uint8Array(Object.values(ev.pixels))
                    }));
                    addLog(`Loaded ${historyEvents.length} events from cache.`);
                } catch (e) { console.error("Cache load failed:", e); }
            }

            try {
                const owners = [...new Set(plots.map(p => p.owner))];
                let newFound = 0;

                for (const owner of owners) {
                    const url = `https://api.whatsonchain.com/v1/bsv/main/address/${owner}/history`;
                    const resp = await fetch(`/api/proxy?url=${encodeURIComponent(url)}&t=${Date.now()}`);
                    if (!resp.ok) continue;

                    const txs = await resp.json();
                    const filteredTxs = txs.filter(tx => {
                        const height = tx.height || tx.block_height || 0;
                        if (startBlock && height < parseInt(startBlock)) return false;
                        if (endBlock && height > parseInt(endBlock)) return false;
                        return true;
                    });

                    const relevantTxs = filteredTxs.slice(0, Math.min(limit, filteredTxs.length));

                    for (const txInfo of relevantTxs) {
                        const txid = txInfo.tx_hash || txInfo.txid;
                        if (historyEvents.some(ev => ev.txid === txid)) continue;

                        const event = await parseHistoryTx(txid, owner);
                        if (event) {
                            historyEvents.push(event);
                            newFound++;
                        }
                    }
                }

                historyEvents.sort((a, b) => (a.height || 0) - (b.height || 0));

                if (newFound > 0) {
                    const toCache = historyEvents.map(ev => ({
                        ...ev,
                        pixels: Array.from(ev.pixels)
                    }));
                    localStorage.setItem(cacheKey, JSON.stringify(toCache));
                    addLog(`Found ${newFound} new events. Total: ${historyEvents.length}`, "success");
                }

                if (historyEvents.length > 0) {
                    document.getElementById('history-controls').style.display = 'block';
                    document.getElementById('history-slider').max = historyEvents.length - 1;
                    document.getElementById('history-slider').value = 0;
                    historyIndex = 0;
                    historyBasePixels = new Uint8Array(currentPixels);
                    updateHistoryInfo();
                    updateQueueUI();
                } else {
                    addLog("No history events found", "error");
                }
            } catch (e) {
                addLog(`History load error: ${e.message}`, "error");
            }
        }

        async function parseHistoryTx(txid, owner) {
            try {
                const url = `https://api.whatsonchain.com/v1/bsv/main/tx/${txid}`;
                const resp = await fetch(`/api/proxy?url=${encodeURIComponent(url)}`);
                if (!resp.ok) return null;

                const tx = await resp.json();

                for (const out of tx.vout) {
                    const asm = out.scriptPubKey?.asm || '';
                    if (asm.includes('OP_RETURN')) {
                        const parts = asm.split(' ');
                        const dataHex = parts.find(p => p.length > 10 && /^[0-9a-f]+$/i.test(p));

                        if (dataHex) {
                            const dataStr = hexToString(dataHex);

                            if (dataStr.includes('UPDATE_') || dataStr.includes('RENT_')) {
                                const plotMatch = dataStr.match(/PLOT(\d+)|P(\d+)/i);
                                const plotIdx = plotMatch ? parseInt(plotMatch[1] || plotMatch[2]) : -1;

                                const commentParts = dataStr.split('|');
                                const comment = commentParts[1] ? commentParts[1].trim() : '';

                                try {
                                    const { PixelPlot28, bsv } = ScryptBundle;
                                    const instance = PixelPlot28.fromTx(new bsv.Transaction(tx.hex), 0);
                                    const plotPixels = decodePixelsFromHex(instance.pixels);

                                    return {
                                        txid: txid,
                                        height: tx.blockheight || 0,
                                        time: tx.blocktime ? new Date(tx.blocktime * 1000) : new Date(),
                                        plotIndex: plotIdx,
                                        type: dataStr.includes('RENT_') ? 'RENT' : 'UPDATE',
                                        data: dataStr,
                                        comment: comment,
                                        pixels: plotPixels,
                                        owner: owner
                                    };
                                } catch (e) { console.error("Failed to decode history instance:", e); }
                            }
                        }
                    }
                }
            } catch (e) { console.error("Parse failed:", e); }
            return null;
        }

        function clearHistoryCache() {
            const cacheKey = `pixel_history_${plots[0].genesisId}`;
            localStorage.removeItem(cacheKey);
            historyEvents = [];
            document.getElementById('history-controls').style.display = 'none';
            addLog("History cache cleared.");
            updateQueueUI();
        }

        function hexToString(hex) {
            let str = '';
            for (let i = 0; i < hex.length; i += 2) {
                const code = parseInt(hex.substr(i, 2), 16);
                if (code >= 32 && code < 127) str += String.fromCharCode(code);
            }
            return str;
        }

        function decodePixelsFromHex(pixelsHex) {
            const rawHex = pixelsHex.startsWith('0x') ? pixelsHex.slice(2) : pixelsHex;
            let n = 0n;
            for (let i = 0; i < rawHex.length; i += 2) {
                const byte = BigInt(parseInt(rawHex.substr(i, 2), 16));
                n |= (byte << (BigInt(i / 2) * 8n));
            }
            const pixels = new Uint8Array(28 * 28);
            for (let i = 0; i < 784; i++) {
                pixels[i] = Number((n >> (BigInt(i) * 5n)) & 31n);
            }
            return pixels;
        }

        function historyStep(dir) {
            historyIndex = Math.max(0, Math.min(historyEvents.length - 1, historyIndex + dir));
            document.getElementById('history-slider').value = historyIndex;
            applyHistoryEvent(historyIndex);
            updateHistoryInfo();
        }

        function historySeek(value) {
            historyIndex = parseInt(value);
            applyHistoryEvent(historyIndex);
            updateHistoryInfo();
        }

        function historyTogglePlay() {
            if (historyPlaying) {
                historyStop();
            } else {
                historyPlay();
            }
        }

        function historyPlay() {
            historyPlaying = true;
            document.getElementById('history-play-btn').classList.add('playing');
            document.getElementById('history-play-btn').textContent = '⏸';

            historyPlayInterval = setInterval(() => {
                if (historyIndex >= historyEvents.length - 1) {
                    historyStop();
                    return;
                }
                historyStep(1);
            }, 500); // 500ms per event
        }

        function historyStop() {
            historyPlaying = false;
            document.getElementById('history-play-btn').classList.remove('playing');
            document.getElementById('history-play-btn').textContent = '▶▶';
            if (historyPlayInterval) {
                clearInterval(historyPlayInterval);
                historyPlayInterval = null;
            }
        }

        function applyHistoryEvent(idx) {
            if (idx < 0 || idx >= historyEvents.length) return;

            const event = historyEvents[idx];

            // Clear previous highlights
            document.querySelectorAll('.pixel.history-updated').forEach(el => {
                el.classList.remove('history-updated');
            });

            // Find correct plot object (lookup by index property, NOT array index)
            const plot = plots.find(p => p.index === event.plotIndex);
            if (!plot) {
                console.warn(`History event for unknown plot index: ${event.plotIndex}`);
                return;
            }

            // Find previous state for this plot in history to show "points update"
            let prevPixels = null;
            for (let i = idx - 1; i >= 0; i--) {
                if (historyEvents[i].plotIndex === event.plotIndex) {
                    prevPixels = historyEvents[i].pixels;
                    break;
                }
            }
            // If no previous history found, use current original pixels as base
            if (!prevPixels) {
                prevPixels = plot.originalPixels;
            }

            // Update the grid pixels for this plot
            if (event.pixels) {
                const changedIndices = [];
                for (let i = 0; i < 784; i++) {
                    const color = event.pixels[i];
                    // Pass the real plot object so getGlobalIdxFromLocal works correctly
                    const globalIdx = getGlobalIdxFromLocal(plot, i);

                    // Update current pixels and background
                    currentPixels[globalIdx] = color;
                    const el = document.getElementById(`p${globalIdx}`);
                    if (el) {
                        el.style.backgroundColor = COLORS[color];
                        el.classList.add('is-filled');
                        // If it changed compared to previous state, highlight it
                        if (!prevPixels || prevPixels[i] !== color) {
                            el.classList.add('history-updated');
                            changedIndices.push(i);
                        }
                    }
                }

                addLog(`History Step ${idx + 1}: Plot ${event.plotIndex} - ${changedIndices.length} pixels updated.`);

                // Zoom to the plot if it's not a rent event (rent events are larger scale)
                if (event.type === 'UPDATE' && changedIndices.length > 0) {
                    const gridIdx = plots.indexOf(plot);
                    if (gridIdx !== -1) zoomToPlot(gridIdx);
                }
            }
        }

        function updateHistoryInfo() {
            const info = document.getElementById('history-info');
            if (historyEvents.length === 0) {
                info.textContent = 'No events';
                return;
            }

            const event = historyEvents[historyIndex];
            const timeStr = event.time ? event.time.toLocaleString() : 'Unknown';
            info.innerHTML = `
                <div style="font-weight:bold; margin-bottom:5px;">${historyIndex + 1} / ${historyEvents.length}</div>
                <div style="color:var(--accent); font-size:12px; font-weight:600;">${event.type} Plot ${event.plotIndex}</div>
                ${event.comment ? `<div style="color:var(--success); font-style:italic; margin:4px 0;">"${event.comment}"</div>` : ''}
                <div style="font-size:9px; color:var(--text-dim); margin-bottom:4px;">${timeStr}</div>
                <div><a href="https://whatsonchain.com/tx/${event.txid}" target="_blank" style="color:var(--accent); text-decoration:none; font-size:10px; border-bottom:1px solid currentColor;">${event.txid.substring(0, 16)}...</a></div>
            `;
        }

        function restoreFromHistory() {
            if (historyBasePixels) {
                // Restore original pixels
                for (let i = 0; i < currentPixels.length; i++) {
                    currentPixels[i] = historyBasePixels[i];
                    const el = document.getElementById(`p${i}`);
                    if (el) {
                        el.style.backgroundColor = COLORS[currentPixels[i]];
                        el.classList.add('is-filled');
                    }
                }
                historyBasePixels = null;
            }
            document.querySelectorAll('.pixel.history-updated').forEach(el => {
                el.classList.remove('history-updated');
            });
            document.getElementById('history-controls').style.display = 'none';
        }

        function updateQueueUI() {
            const queueCubes = document.getElementById('queue-cubes');
            const errorCubesEl = document.getElementById('error-cubes');
            const errorSection = document.getElementById('queue-errors');
            const queueTitle = document.getElementById('queue-title');

            queueCubes.innerHTML = '';

            if (currentMode === 'history') {
                queueTitle.innerText = "HISTORY EVENTS";
                if (historyEvents.length === 0) {
                    queueCubes.innerHTML = '<div style="color:rgba(255,255,255,0.2); text-align:center; padding:20px; width:100%;">No history loaded</div>';
                } else {
                    // Add "Clear History" cube/action
                    const clearBtn = document.createElement('div');
                    clearBtn.className = 'queue-cube error';
                    clearBtn.innerHTML = '<span class="plot-num">✕</span><span class="count">CLEAR</span>';
                    clearBtn.onclick = clearHistoryCache;
                    clearBtn.title = "Clear all cached history";
                    queueCubes.appendChild(clearBtn);

                    historyEvents.slice().reverse().forEach((ev, idx) => {
                        const actualIdx = historyEvents.length - 1 - idx;
                        const cube = document.createElement('div');
                        cube.className = 'queue-cube';
                        if (actualIdx === historyIndex) cube.style.borderColor = 'var(--success)';
                        cube.innerHTML = `
    <span class="plot-num">${ev.plotIndex}</span>
    <span class="count">${ev.type === 'RENT' ? 'RENT' : 'UPD'}</span>
`;
                        cube.onclick = () => {
                            historyIndex = actualIdx;
                            document.getElementById('history-slider').value = historyIndex;
                            applyHistoryEvent(historyIndex);
                            updateHistoryInfo();
                            updateQueueUI();
                        };
                        cube.title = `${ev.type} Plot ${ev.plotIndex} at block ${ev.height}\n${ev.comment || 'No comment'}`;
                        queueCubes.appendChild(cube);
                    });
                }
                errorSection.style.display = 'none';
                return;
            }

            queueTitle.innerText = "TRANSACTION QUEUE";
            let totalActions = 0;

            // Pixel update cubes
            plots.forEach(plot => {
                if (plot.modifiedIndices.size > 0) {
                    totalActions++;
                    const cube = document.createElement('div');
                    cube.className = 'queue-cube';
                    cube.dataset.plotIndex = plot.index;
                    cube.innerHTML = `
<span class="plot-num">${plot.index}</span>
<span class="count">${plot.modifiedIndices.size}px</span>
                    `;
                    cube.onclick = () => zoomToPlot(plot.index);
                    cube.title = `Plot ${plot.index}: ${plot.modifiedIndices.size} pixels - Click to zoom`;
                    queueCubes.appendChild(cube);
                }
            });

            // Rent cubes with quadrant grid visualization
            plots.forEach(plot => {
                if (plot.queuedRents.size > 0) {
                    totalActions++;
                    const cube = document.createElement('div');
                    cube.className = 'queue-cube rent-cube';
                    cube.dataset.plotIndex = plot.index;

                    // Build quadrant grid visualization
                    const quadGrid = `
<div class="rent-quad-grid">
    <div class="rent-quad-cell ${plot.queuedRents.has(0) ? 'filled' : ''}"></div>
    <div class="rent-quad-cell ${plot.queuedRents.has(1) ? 'filled' : ''}"></div>
    <div class="rent-quad-cell ${plot.queuedRents.has(2) ? 'filled' : ''}"></div>
    <div class="rent-quad-cell ${plot.queuedRents.has(3) ? 'filled' : ''}"></div>
</div>
                    `;

                    cube.innerHTML = `
${quadGrid}
<span class="count">P${plot.index}</span>
                    `;
                    cube.onclick = () => zoomToPlot(plot.index);
                    const qList = Array.from(plot.queuedRents).join(',');
                    cube.title = `Plot ${plot.index}: Rent Q[${qList}] for ${rentPeriod} blocks (${plot.queuedRents.size} tx) - Click to zoom`;
                    queueCubes.appendChild(cube);
                }
            });

            if (totalActions === 0) {
                queueCubes.innerHTML = '<div style="color:rgba(255,255,255,0.2); text-align:center; padding:20px; width:100%;">No pending actions</div>';
            }

            // Error cubes
            if (errorQueue.length > 0) {
                errorSection.style.display = 'block';
                errorCubesEl.innerHTML = '';
                errorQueue.forEach(err => {
                    const cube = document.createElement('div');
                    cube.className = 'queue-cube error';
                    cube.innerHTML = `
<span class="plot-num">${err.plotIndex}</span>
<span class="count">${err.type}</span>
                    `;
                    cube.onclick = () => zoomToPlot(err.plotIndex);
                    cube.title = `Error: ${err.message} - Click to zoom`;
                    errorCubesEl.appendChild(cube);
                });
            } else {
                errorSection.style.display = 'none';
            }
        }

        function addLog(msg, type = '', txid = null) {
            const stream = document.getElementById('log-stream');
            const div = document.createElement('div');
            div.className = 'log-msg' + (type ? ' ' + type : '');

            const time = new Date().toLocaleTimeString();

            if (txid) {
                // Create clickable TX link
                const shortTx = txid.substring(0, 8) + '...';
                div.innerHTML = `[${time}] ${msg} <a href="https://whatsonchain.com/tx/${txid}" target="_blank" style="color: var(--accent); text-decoration: underline;">${shortTx}</a>`;
            } else {
                div.innerText = `[${time}] ${msg}`;
            }

            stream.prepend(div);
            console.log(msg, txid || '');
        }

        function addTxLog(action, plotIdx, txid) {
            addLog(`${action} Plot ${plotIdx}:`, 'success', txid);
        }

        async function findHead(txid, outIdx = 0, userAddress = null) {
            try {
                const targetUrl = 'https://api.whatsonchain.com/v1/bsv/main/utxos/spent';
                const resp = await fetch(`/api/proxy?url=${encodeURIComponent(targetUrl)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ utxos: [{ txid, vout: outIdx }] })
                });
                const data = await resp.json();
                const info = data[0];
                if (info && info.spentIn) {
                    return findHead(info.spentIn.txid || info.spentIn.tx_hash, 0, userAddress);
                }
                return txid;
            } catch (e) { return txid; }
        }

        async function getProvider() {
            const { WhatsonchainProvider, bsv } = ScryptBundle;
            const p = new WhatsonchainProvider(bsv.Networks.mainnet);

            // Use dynamic fee rate from slider
            const rate = feeRate;
            p._feePerKb = rate;
            p.getFeePerKb = async () => rate;
            p.getFeeRate = async () => ({ mine: rate, relay: rate });

            // Override sendRawTransaction for WhatsOnChain (shows unconfirmed txs)
            p.sendRawTransaction = async function (txHex) {
                const txBytes = txHex.length / 2;
                const estimatedFee = Math.ceil(txBytes * rate / 1000);
                addLog(`Broadcasting ${txBytes} bytes, ~${estimatedFee} sat fee`);
                const url = 'https://api.whatsonchain.com/v1/bsv/main/tx/raw';
                const response = await fetch(`/api/proxy?url=${encodeURIComponent(url)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ txhex: txHex })
                });
                const result = await response.text();
                if (!response.ok) {
                    throw new Error(`WOC Error ${response.status}: ${result}`);
                }
                return result.replace(/^"|"$/g, '');
            };

            return p;
        }



        function decodeBase64(encodedData) {
            try {
                return atob(encodedData);
            } catch (e) {
                return encodedData;
            }
        }

        async function refreshWallet() {
            const wif = document.getElementById('wif-input').value.trim();
            const balanceEl = document.getElementById('display-wallet-balance');
            const addrEl = document.getElementById('display-wallet-addr');
            const labelEl = document.getElementById('display-wallet-label');

            if (!wif) {
                balanceEl.innerText = "No Wallet";
                addrEl.innerText = "Enter WIF above";
                labelEl.style.display = 'none';
                return;
            }

            try {
                const { bsv } = ScryptBundle;
                const priv = bsv.PrivateKey.fromWIF(wif);
                const addr = priv.toAddress().toString();
                addrEl.innerText = addr.substring(0, 6) + '...' + addr.substring(addr.length - 6);
                addrEl.title = addr;
                labelEl.style.display = 'none';

                balanceEl.innerText = "Loading...";
                const url = `https://api.whatsonchain.com/v1/bsv/main/address/${addr}/balance`;
                const res = await fetch(`/api/proxy?url=${encodeURIComponent(url)}&t=${Date.now()}`);
                const data = await res.json();
                balanceEl.innerText = ((data.confirmed || 0) + (data.unconfirmed || 0)) + ' SAT';
            } catch (e) {
                console.error("Wallet Refresh Error:", e);
                balanceEl.innerText = "Error";
                addrEl.innerText = "Invalid WIF";
            }
        }

        function getWif() {
            const val = document.getElementById('wif-input').value.trim();
            if (!val) {
                alert("Please enter a WIF key to transact.");
                throw new Error("No WIF provided");
            }
            return val;
        }

        async function startExecution() {
            const btn = document.getElementById('process-btn');
            btn.disabled = true;
            btn.innerText = "EXECUTING...";

            try {
                const { TestWallet, bsv } = ScryptBundle;
                const wif = getWif();
                const priv = bsv.PrivateKey.fromWIF(wif);
                const provider = await getProvider();
                const signer = new TestWallet(priv, provider);

                errorQueue = []; // Clear previous errors

                for (const plot of plots) {
                    if (plot.modifiedIndices.size === 0 && plot.queuedRents.size === 0) continue;

                    // Mark cube as processing
                    markCubeProcessing(plot.index, true);
                    addLog(`Processing Plot ${plot.index}...`);

                    try {
                        await plot.instance.connect(signer);

                        // 1. Handle Rents - each quadrant is a separate TX
                        if (plot.queuedRents.size > 0) {
                            const rentsToProcess = Array.from(plot.queuedRents);
                            const failedRents = [];
                            for (const qIdx of rentsToProcess) {
                                try {
                                    const txid = await executeRent(plot, qIdx, signer);
                                    addTxLog(`Rented Q${qIdx}`, plot.index, txid);
                                    plot.queuedRents.delete(qIdx);
                                    updateQueueUI();
                                    await new Promise(r => setTimeout(r, 500));
                                } catch (rentErr) {
                                    addLog(`Q${qIdx} failed: ${rentErr.message}`, "error");
                                    failedRents.push({ qIdx, error: rentErr.message });
                                }
                            }
                            // Only clear visual selection for successful rents
                            if (plot.queuedRents.size === 0) {
                                // All handled
                            }
                            updateSelectionOverlay();
                            // Add failed rents to error queue for retry
                            if (failedRents.length > 0) {
                                errorQueue.push({
                                    plotIndex: plot.index,
                                    type: 'RENT',
                                    failedQuadrants: failedRents,
                                    message: `${failedRents.length} quadrant(s) failed`
                                });
                            }
                        }

                        // 2. Handle Pixels
                        const list = Array.from(plot.modifiedIndices);
                        const batches = Math.ceil(list.length / 30);
                        for (let i = 0; i < batches; i++) {
                            const batch = list.slice(i * 30, (i + 1) * 30);
                            const txid = await executeBatch(plot, batch, signer);
                            addTxLog(`Updated ${batch.length}px`, plot.index, txid);
                            await new Promise(r => setTimeout(r, 500));
                        }

                        markCubeProcessing(plot.index, false);
                    } catch (plotError) {
                        addLog(`Plot ${plot.index} Error: ${plotError.message}`, "error");
                        // Only add to error queue if there's still work to do
                        if (plot.queuedRents.size > 0 || plot.modifiedIndices.size > 0) {
                            errorQueue.push({
                                plotIndex: plot.index,
                                type: plot.queuedRents.size > 0 ? 'RENT' : 'PX',
                                message: plotError.message
                            });
                        }
                        markCubeProcessing(plot.index, false, true);
                    }

                    markCubeProcessing(plot.index, false);
                    updateQueueUI();
                }

                // Retry errors with new head
                if (errorQueue.length > 0) {
                    addLog(`Retrying ${errorQueue.length} failed plots with fresh heads...`);
                    await retryErrorQueue(signer, provider);
                }

                addLog("Execution complete!", "success");
                await refreshWallet();
            } catch (e) {
                addLog(`Execution Error: ${e.message}`, "error");
            } finally {
                btn.disabled = false;
                btn.innerText = "EXECUTE";
                updateQueueUI();
            }
        }

        function markCubeProcessing(plotIdx, processing, isError = false) {
            const cubes = document.querySelectorAll('.queue-cube');
            cubes.forEach(cube => {
                if (cube.querySelector('.plot-num')?.textContent === String(plotIdx)) {
                    cube.classList.toggle('processing', processing);
                    if (isError) cube.classList.add('error');
                }
            });
        }

        async function retryErrorQueue(signer, provider) {
            const { PixelPlot28, bsv } = ScryptBundle;
            const errorsToRetry = [...errorQueue];
            errorQueue = [];

            for (const err of errorsToRetry) {
                const plot = plots[err.plotIndex];
                addLog(`Finding new head for Plot ${err.plotIndex}...`);

                try {
                    // Find new head
                    const newHead = await findHead(plot.genesisId, 0);
                    if (newHead !== plot.headId) {
                        plot.headId = newHead;
                        const tx = await provider.getTransaction(newHead);
                        plot.instance = PixelPlot28.fromTx(tx, 0);
                        addLog(`Found new head: ${newHead.substring(0, 10)}...`);
                    }

                    await plot.instance.connect(signer);

                    if (err.type === 'RENT' && plot.queuedRents.size > 0) {
                        const rentsToProcess = Array.from(plot.queuedRents);
                        const stillFailed = [];
                        for (const qIdx of rentsToProcess) {
                            try {
                                const txid = await executeRent(plot, qIdx, signer);
                                addTxLog(`Retry Rented Q${qIdx}`, plot.index, txid);
                                plot.queuedRents.delete(qIdx);
                            } catch (rentErr) {
                                // Check if it's "already rented" - don't retry these
                                if (rentErr.message.includes('already rented')) {
                                    addLog(`Q${qIdx} already rented, skipping`, "error");
                                    plot.queuedRents.delete(qIdx);
                                } else {
                                    stillFailed.push(qIdx);
                                    addLog(`Q${qIdx} retry failed: ${rentErr.message}`, "error");
                                }
                            }
                        }
                        if (plot.queuedRents.size === 0) {
                            updateSelectionOverlay();
                        }
                        if (stillFailed.length > 0) {
                            errorQueue.push({
                                plotIndex: err.plotIndex,
                                type: 'RENT',
                                message: `${stillFailed.length} quadrant(s) still failing`
                            });
                        }
                    } else if (plot.modifiedIndices.size > 0) {
                        const list = Array.from(plot.modifiedIndices);
                        const batches = Math.ceil(list.length / 30);
                        for (let i = 0; i < batches; i++) {
                            const batch = list.slice(i * 30, (i + 1) * 30);
                            const txid = await executeBatch(plot, batch, signer);
                            addTxLog(`Retry Updated ${batch.length}px`, plot.index, txid);
                        }
                    }

                    if (plot.queuedRents.size === 0 && plot.modifiedIndices.size === 0) {
                        addLog(`Plot ${err.plotIndex} retry complete`, "success");
                    }
                } catch (retryErr) {
                    addLog(`Plot ${err.plotIndex} retry failed: ${retryErr.message}`, "error");
                    errorQueue.push(err);
                }
            }
            updateQueueUI();
        }

        async function executeRent(plot, qIdx, signer) {
            const { bsv, PubKeyHash, toByteString, Utils, PixelPlot28 } = ScryptBundle;
            const wif = getWif();
            const priv = bsv.PrivateKey.fromWIF(wif);
            const pkh = priv.toAddress().hashBuffer.toString('hex');

            const numBlocks = BigInt(rentPeriod);
            const cost = numBlocks * plot.instance.rentPricePerBlock;

            addLog(`Renting Plot ${plot.index} Q${qIdx} for ${rentPeriod} blocks (${cost} sats)`);

            // Ensure instance is connected
            await plot.instance.connect(signer);

            // Manual Builder to handle nLockTime and outputs order precisely
            plot.instance.bindTxBuilder('rent', async (current, options, quadrant, renter, numBlocks, opReturnData) => {
                const nextInstance = current.next();
                const lt = BigInt(options.lockTime || 0);
                nextInstance.renters[Number(quadrant)] = renter;
                nextInstance.rentEnds[Number(quadrant)] = lt + numBlocks;

                const cost = numBlocks * current.rentPricePerBlock;

                let tx = new bsv.Transaction()
                    .addInput(current.buildContractInput())
                    .addOutput(new bsv.Transaction.Output({
                        script: bsv.Script.fromHex(nextInstance.lockingScript.toHex()),
                        satoshis: 1
                    }))
                    .addOutput(new bsv.Transaction.Output({
                        script: bsv.Script.fromHex(Utils.buildPublicKeyHashScript(current.owner)),
                        satoshis: Number(cost)
                    }))
                    .addOutput(new bsv.Transaction.Output({
                        script: bsv.Script.fromHex(Utils.buildOpreturnScript(opReturnData)),
                        satoshis: 0
                    }));

                if (options.lockTime !== undefined) {
                    tx.nLockTime = Number(options.lockTime);
                    // Enable nLockTime by setting sequence < MAX
                    tx.inputs[0].sequenceNumber = 0xFFFFFFFE;
                }

                if (options.changeAddress) {
                    tx.change(options.changeAddress);
                }

                return {
                    tx,
                    atInputIndex: 0,
                    nexts: [{ instance: nextInstance, balance: 1, atOutputIndex: 0 }]
                };
            });

            const comment = document.getElementById('tx-comment').value.trim();
            const opReturnData = `RENT_Q${qIdx}_P${plot.index}_${rentPeriod}BLK${comment ? ' | ' + comment : ''}`;

            const txResult = await plot.instance.methods.rent(
                BigInt(qIdx),
                PubKeyHash(toByteString(pkh)),
                numBlocks,
                toByteString(opReturnData, true),
                {
                    changeAddress: priv.toAddress(),
                    lockTime: currentBlockHeight
                }
            );

            plot.instance = txResult.next ? txResult.next.instance : plot.instance;
            plot.headId = txResult.tx.id;

            return txResult.tx.id;
        }

        async function executeBatch(plot, list, signer) {
            const { bsv, toByteString, Utils, PixelPlot28 } = ScryptBundle;
            const wif = getWif();
            const priv = bsv.PrivateKey.fromWIF(wif);

            const updates = list.map(idx => ({
                index: BigInt(idx),
                color: BigInt(currentPixels[getGlobalIdxFromLocal(plot, idx)])
            }));
            const numUpdates = updates.length;
            while (updates.length < 30) updates.push({ index: 0n, color: 0n });

            addLog(`Updating ${numUpdates} pixels on Plot ${plot.index}...`);

            // Ensure connected
            await plot.instance.connect(signer);

            // Manual builder for updatePixels to handle nLockTime and ordered gains
            plot.instance.bindTxBuilder('updatePixels', async (current, options, updates, numUpdates, opReturnData) => {
                const nextInstance = current.next();
                const lt = BigInt(options.lockTime || 0);

                let ownerGain = 0n;
                let renterGains = [0n, 0n, 0n, 0n];

                // Simulate logic for outputs order
                let pixelsInt = ScryptBundle.byteString2Int(current.pixels);
                for (let i = 0; i < 30; i++) {
                    if (BigInt(i) < numUpdates) {
                        const u = updates[i];
                        const idx = u.index;
                        const color = u.color;
                        const x = idx % 28n;
                        const y = idx / 28n;
                        const qIdx = Number((y / 14n) * 2n + (x / 14n));

                        const rentEnd = current.rentEnds[qIdx];
                        const isRented = lt < rentEnd;

                        let price = 3n;
                        if (color <= 1n) price = 1n;
                        else if (color >= 28n) price = 5n;

                        if (isRented) {
                            ownerGain += 1n;
                            renterGains[qIdx] += (price - 1n);
                        } else {
                            ownerGain += price;
                        }

                        const shift = idx * 5n;
                        const currentBits = (pixelsInt >> shift) & 31n;
                        pixelsInt = pixelsInt - (currentBits << shift) + (color << shift);
                    }
                }
                nextInstance.pixels = ScryptBundle.int2ByteString(pixelsInt, 491n);

                let tx = new bsv.Transaction()
                    .addInput(current.buildContractInput())
                    .addOutput(new bsv.Transaction.Output({
                        script: bsv.Script.fromHex(nextInstance.lockingScript.toHex()),
                        satoshis: 1
                    }));

                if (ownerGain > 0n) {
                    tx.addOutput(new bsv.Transaction.Output({
                        script: bsv.Script.fromHex(Utils.buildPublicKeyHashScript(current.owner)),
                        satoshis: Number(ownerGain)
                    }));
                }

                for (let q = 0; q < 4; q++) {
                    if (renterGains[q] > 0n) {
                        tx.addOutput(new bsv.Transaction.Output({
                            script: bsv.Script.fromHex(Utils.buildPublicKeyHashScript(current.renters[q])),
                            satoshis: Number(renterGains[q])
                        }));
                    }
                }

                tx.addOutput(new bsv.Transaction.Output({
                    script: bsv.Script.fromHex(Utils.buildOpreturnScript(opReturnData)),
                    satoshis: 0
                }));

                if (options.lockTime !== undefined) {
                    tx.nLockTime = Number(options.lockTime);
                    tx.inputs[0].sequenceNumber = 0xFFFFFFFE;
                }

                if (options.changeAddress) {
                    tx.change(options.changeAddress);
                }

                return {
                    tx,
                    atInputIndex: 0,
                    nexts: [{ instance: nextInstance, balance: 1, atOutputIndex: 0 }]
                };
            });

            const comment = document.getElementById('tx-comment').value.trim();
            const opReturnData = `UPDATE_${numUpdates}PX_PLOT${plot.index}${comment ? ' | ' + comment : ''}`;

            const txResult = await plot.instance.methods.updatePixels(
                updates,
                BigInt(numUpdates),
                toByteString(opReturnData, true),
                {
                    changeAddress: priv.toAddress(),
                    lockTime: currentBlockHeight
                }
            );

            plot.instance = txResult.next ? txResult.next.instance : plot.instance;
            plot.headId = txResult.tx.id;

            list.forEach(idx => {
                plot.originalPixels[idx] = currentPixels[getGlobalIdxFromLocal(plot, idx)];
                plot.modifiedIndices.delete(idx);
            });
            updateQueueUI();

            return txResult.tx.id;
        }

        function getGlobalIdxFromLocal(plot, localIdx) {
            const gridIdx = plots.indexOf(plot);
            const plotRow = Math.floor(gridIdx / 10);
            const plotCol = gridIdx % 10;

            const localY = Math.floor(localIdx / 28);
            const localX = localIdx % 28;
            const globalY = plotRow * 28 + localY;
            const globalX = plotCol * 28 + localX;
            return globalY * 280 + globalX;
        }

        function bigintToLEHex(n, bytesCount) {
            // Ensure we handle negative bigints (though they shouldn't be negative in our logic anymore)
            // but for safety with bit 3919:
            let hex = n.toString(16).replace('-', '');
            if (hex.length % 2 !== 0) hex = '0' + hex;

            const parts = [];
            for (let i = 0; i < hex.length; i += 2) {
                parts.push(hex.substring(i, i + 2));
            }
            parts.reverse();
            let res = parts.join('');
            return res.padEnd(bytesCount * 2, '0').slice(0, bytesCount * 2);
        }

        function resetAll() {
            plots.forEach(plot => {
                plot.modifiedIndices.forEach(localIdx => {
                    const globalIdx = getGlobalIdxFromLocal(plot, localIdx);
                    // Reset pixel data
                    currentPixels[globalIdx] = plot.originalPixels[localIdx];
                });
                plot.modifiedIndices.clear();
                plot.queuedRents.clear();
            });

            // Redraw everything
            requestAnimationFrame(redrawGrid);
            updateSelectionOverlay();

            errorQueue = [];
            hideRentInfo();
            updateQueueUI();
            addLog("All pending changes reset.");
        }

        function applySettings() {
            refreshWallet();
            addLog("Wallet settings updated.", "success");
        }
    </script>
</body>

</html>